{"id":"f4a5d541-0bf7-48b6-a5f3-ce8e3a9dc2ba","zed":"context","version":"0.4.0","text":"\n\n\n這是 EsAggregateRoot 的程式碼，可以用來實作 Event Sourced Aggregate: \n```\n\n/**\n * {@code EsAggregateRoot} is a class for representing domain-driven design\n * aggregate root using event sourcing.\n *\n * @param <ID> the type parameter for aggregate root id\n * @param <E>  the type parameter for domain event\n *\n * @author Teddy Chen \n * @author ezKanban team\n * @since 1.0\n */\npublic abstract class EsAggregateRoot<ID, E extends DomainEvent> extends AggregateRoot<ID, E> {\n\n//region :Constructors\n    protected EsAggregateRoot() {\n        super();\n    }\n\n    public EsAggregateRoot(List<E> events) {\n        this();\n        requireNotNull(\"Domain events\", events);\n\n        replayEvents(events);\n        clearDomainEvents();\n\n        ensure(\"Domain event size is 0\", () -> getDomainEvents().size() == 0);\n        ensure(\"Aggregate id cannot be null\", () -> null != getId());\n    }\n\n    protected void replayEvents(List<E> events) {\n        events.forEach(this::apply);\n    }\n    //endregion\n\n    //region :Behaviors for the DomainEventSource\n    // template method\n    @Override\n    public final void apply(E event) {\n        if (!(event instanceof DomainEvent.ConstructionEvent))\n            ensureInvariant();\n        try {\n            when(event);\n        } catch (RuntimeException e) {\n            if (event instanceof DomainEvent.ConstructionEvent) {\n                throw e;\n            }\n            ensureInvariant(e);\n        }\n\n        if (!(event instanceof DomainEvent.DestructionEvent))\n            ensureInvariant();\n\n        addDomainEvent(event);\n    }\n    //endregion\n\n    private void ensureInvariant(RuntimeException leadingException) {\n        try {\n            ensureInvariant();\n            if (null != leadingException)\n                throw leadingException;\n        } catch (ClassInvariantViolationException ce) {\n            ce.initCause(leadingException);\n            throw ce;\n        }\n    }\n\n    //region hook methods\n    protected void ensureInvariant() {\n    }\n\n    protected abstract void when(E event);\n    //endregion\n\n    //region: event sourcing\n    abstract public String getCategory();\n\n    public final String getStreamName() {\n        return getCategory() + \"-\" + getId().toString();\n    }\n\n    public static String getStreamName(String category, String id) {\n        return category + \"-\" + id;\n    }\n    //endregion\n}\n```\n感謝您分享這段程式碼。這是一個實作事件溯源（Event Sourcing）模式的抽象基礎類別 `EsAggregateRoot`。我來解釋一下這個類別的主要功能和設計：\n\n### EsAggregateRoot 類別概述\n\n此類別是用於實作基於事件溯源的領域驅動設計（DDD）聚合根（Aggregate Root）。\n\n### 主要特點：\n\n1. **泛型參數**:\n   - `ID`: 聚合根的識別符類型\n   - `E`: 領域事件類型，必須繼承自 `DomainEvent`\n\n2. **構造函數**:\n   - 默認構造函數：無參數\n   - 基於事件列表的構造函數：接受一系列領域事件，並重新播放這些事件來構建聚合根狀態\n\n3. **事件應用機制**:\n   - `apply(E event)` 方法：將事件應用到聚合根，更新其狀態\n   - 在應用事件前後檢查不變量（invariant）\n   - 處理例外情況\n\n4. **核心方法**:\n   - `when(E event)`: 抽象方法，子類必須實現此方法來定義如何處理特定類型的事件\n   - `ensureInvariant()`: 子類可覆寫此方法以定義聚合根的業務規則和不變條件\n\n5. **事件溯源相關**:\n   - `getCategory()`: 抽象方法，返回聚合根的類別（用於事件流命名）\n   - `getStreamName()`: 獲取事件流的名稱，通常由類別和 ID 組合而成\n\n### 使用方式：\n\n要使用此類別創建一個事件溯源的聚合根，您需要：\n\n1. 創建一個繼承自 `EsAggregateRoot` 的具體類別\n2. 實現 `when(E event)` 方法，定義如何處理各種領域事件\n3. 實現 `getCategory()` 方法，返回聚合根的類別標識\n4. 選擇性地覆寫 `ensureInvariant()` 方法，定義業務規則和不變條件\n\n這種設計遵循了事件溯源的核心原則：聚合根的狀態是所有領域事件的結果。通過重新播放事件，可以在任何時間點重建聚合根的狀態。\n這是 DomainEvent 的介面程式碼: \n```\n/**\n * {@code DomainEvent} is an interface for representing domain events in \n * domain-driven design.\n *\n * @author Teddy Chen \n * @author ezKanban team\n * @since 1.0\n */\npublic interface DomainEvent extends Serializable {\n\tUUID id();\n\n\tInstant occurredOn();\n\n\tString aggregateId();\n\n\t/**\n\t * The domain event which is created when initializing object.\n\t */\n\tinterface ConstructionEvent extends DomainEvent {}\n\n\t/**\n\t * The domain event which is created when deleting object.\n\t */\n\tinterface DestructionEvent extends DomainEvent {}\n}\n```\n感謝您分享 `DomainEvent` 介面的程式碼。這個介面定義了領域事件在領域驅動設計中的基本結構。\n\n### DomainEvent 介面概述\n\n`DomainEvent` 是一個代表領域中發生事件的介面，它繼承自 `Serializable`，這意味著所有的領域事件都可以被序列化（對於事件存儲和傳輸非常重要）。\n\n### 主要方法和功能：\n\n1. **核心方法**：\n   - `UUID id()`: 返回事件的唯一識別符\n   - `Instant occurredOn()`: 返回事件發生的時間點\n   - `String aggregateId()`: 返回與此事件相關聯的聚合根的識別符\n\n2. **特殊事件類型**：\n   - `ConstructionEvent` 介面：標記用於初始化物件時創建的領域事件\n   - `DestructionEvent` 介面：標記用於刪除物件時創建的領域事件\n\n### 在事件溯源中的應用：\n\n1. 這個介面與先前的 `EsAggregateRoot` 結合使用，形成了完整的事件溯源基礎架構。\n\n2. 在 `EsAggregateRoot` 中，`apply` 方法會根據事件的類型（是否為 `ConstructionEvent` 或 `DestructionEvent`）採取不同的處理方式，特別是在檢查不變量（invariants）方面。\n\n3. 每個事件都有唯一識別符、發生時間和關聯的聚合根ID，這些信息對於事件記錄、重播和調試都很重要。\n\n### 實作這個介面的注意事項：\n\n1. 領域事件應該是不可變的（immutable），一旦創建就不應該被修改。\n\n2. 事件應該包含足夠的信息，以便可以理解發生了什麼變化，但不應該包含過多的細節。\n\n3. 特殊的事件類型（`ConstructionEvent` 和 `DestructionEvent`）用於標記聚合根生命週期的起始和結束，這在事件溯源系統中有特殊的處理方式。\n\n這種設計使得系統能夠追蹤和重建聚合根的完整歷史，這是事件溯源模式的核心優勢之一。\n這是 uContract 專案的 Contract程式碼，可以用來幫 EsAggregateRoot 定義合約，包含 preconditions, postconditions, and aggregate invariants:\n```\n/**\n * {@code Contract} is a class for specifying pre-conditions, post-conditions\n * and class invariants.\n *\n * @author Teddy Chen\n * @author EzKanban Team\n * @see PreconditionViolationException\n * @see PostconditionViolationException\n * @see ClassInvariantViolationException\n * @see CheckViolationException\n * @since 0.1\n */\npublic class Contract {\n    /**\n     * The constant {@code DBC} is for controlling the evaluation of contracts.\n     * The default value of {@code DBC} is {@code true};\n     * When environment variable DBC=on, {@code DBC} is {@code true},\n     * and contracts will be evaluated.\n     * When environment variable DBC=off, {@code DBC} is {@code false},\n     * and contracts will not be evaluated.\n     */\n    public static boolean DBC;\n\n    /**\n     * The constant {@code CHECK_PRE} is for controlling the evaluation\n     * of pre-conditions.\n     * The default value of {@code CHECK_PRE} is {@code true};\n     * When {@code CHECK_PRE} is {@code true}, pre-condition will be evaluated.\n     * When {@code CHECK_PRE} is {@code false}, pre-condition\n     * will not be evaluated.\n     */\n    public static boolean CHECK_PRE;\n\n    /**\n     * The constant {@code CHECK_POST} is for controlling the evaluation\n     * of post-conditions.\n     * The default value of {@code CHECK_POST} is {@code true};\n     * When {@code CHECK_POST} is {@code true}, post-condition\n     * will be evaluated.\n     * When {@code CHECK_POST} is {@code false}, post-condition\n     * will not be evaluated.\n     */\n    public static boolean CHECK_POST;\n\n    /**\n     * The constant {@code CHECK_INV} is for controlling the evaluation\n     * of class invariants.\n     * The default value of {@code CHECK_INV} is {@code true};\n     * When {@code CHECK_INV} is {@code true}, class invariants\n     * will be evaluated.\n     * When {@code CHECK_INV} is {@code false}, class invariants\n     * will not be evaluated.\n     */\n    public static boolean CHECK_INV;\n\n    /**\n     * The constant {@code CHECK_CHECK} is for controlling the evaluation\n     * of keyword check.\n     * The default value of {@code CHECK_CHECK} is {@code true};\n     * When {@code CHECK_CHECK} is {@code true}, keyword check\n     * will be evaluated.\n     * When {@code CHECK_CHECK} is {@code false}, keyword check\n     * will not be evaluated.\n     */\n    public static boolean CHECK_CHECK;\n\n    /**\n     * The constant {@code GENERATE_DOC} is for controlling the documentation\n     * generating after execution of contract.\n     * The default value of {@code GENERATE_DOC} is {@code false};\n     * When {@code GENERATE_DOC} is {@code true}, the document\n     * will be generated.\n     * When {@code GENERATE_DOC} is {@code false}, the document\n     * will not be generated.\n     */\n    public static boolean GENERATE_DOC;\n\n    /**\n     * The constant {@code runtime} is for storing the documentation string.\n     */\n    public static Map<String, List<String>> runtime = new HashMap<>();\n\n    private static final JsonMapper mapper;\n\n    static {\n        Logger logger = Logger.getLogger(\"uContract\");\n        DBC = true;\n        GENERATE_DOC = false;\n        var dbc_env = System.getenv(\"DBC\");\n        logger.info(\"DBC ENV: \" + dbc_env);\n        if (\"off\".equals(dbc_env)) {\n            DBC = false;\n        }\n\n        var doc = System.getenv(\"DBC_DOC\");\n        logger.info(\"DBC_DOC: \" + doc);\n        if (\"on\".equals(doc)) {\n            GENERATE_DOC = true;\n        }\n\n        CHECK_PRE = DBC;\n        CHECK_POST = DBC;\n        CHECK_INV = DBC;\n        CHECK_CHECK = DBC;\n\n        var pre_env = System.getenv(\"DBC_PRE\");\n        if (\"off\".equals(pre_env)){\n            logger.info(\"PRE ENV: \" + pre_env);\n            CHECK_PRE = false;\n        }\n\n        var post_env = System.getenv(\"DBC_POST\");\n        if (\"off\".equals(post_env)){\n            logger.info(\"POST ENV: \" + post_env);\n            CHECK_POST = false;\n        }\n\n        var inv_env = System.getenv(\"DBC_INV\");\n        if (\"off\".equals(inv_env)){\n            logger.info(\"INV ENV: \" + inv_env);\n            CHECK_INV = false;\n        }\n\n        var check_env = System.getenv(\"DBC_CHECK\");\n        if (\"off\".equals(check_env)){\n            logger.info(\"CHECK ENV: \" + check_env);\n            CHECK_CHECK = false;\n        }\n\n        mapper = JsonMapper.builder()\n                .addModule(new ParameterNamesModule())\n                .addModule(new Jdk8Module())\n                .addModule(new JavaTimeModule())\n                .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)\n                .configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true)\n                .build();\n        mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);\n    }\n\n    /**\n     * Check a condition at a certain stage.\n     *\n     * @param annotation the description of the check\n     * @param assertion a lambda expression to represent the assertion\n     *                  of the pre-condition\n     * @throws CheckViolationException if the assertion returns false\n     */\n    public static void check(String annotation, BooleanSupplier assertion) {\n        var msg = format(\"Check %s\", annotation);\n        checkImpl(msg, assertion);\n    }\n\n    /**\n     * Check if the operation is supported or not.\n     *\n     * @param runnable the function to check if it is unsupported.\n     * @return {@code true} if the operation is unsupported.\n     */\n    public static boolean checkUnsupportedOperation(Runnable runnable) {\n        try {\n            runnable.run();\n            return false;\n        } catch (UnsupportedOperationException e) {\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * Check a pre-condition.\n     *\n     * @param annotation the description of the pre-condition\n     * @param assertion  a lambda expression to represent the assertion\n     *                   of the pre-condition\n     * @throws PreconditionViolationException\n     *          if the {@code assertion} returns {@code false}\n     */\n    public static void require(String annotation, BooleanSupplier assertion) {\n        var msg = format(\"Require %s\", annotation);\n        recordContract(msg);\n        requireImpl(msg, assertion);\n    }\n\n    /**\n     * Check a pre-condition of an object cannot be {@code null}.\n     *\n     * @param annotation the description of the pre-condition\n     * @param obj        the object\n     * @throws PreconditionViolationException\n     *          if the {@code obj} is {@code null}\n     */\n    public static void requireNotNull(String annotation, Object obj){\n        var msg = format(\"Require [%s] cannot be null\", annotation);\n        recordContract(msg);\n        requireImpl(msg, () -> null != obj);\n    }\n\n    /**\n     * Check a pre-condition of a string cannot be empty.\n     *\n     * @param annotation the description of the pre-condition\n     * @param str        the string\n     * @throws PreconditionViolationException if the {@code str} is empty\n     */\n    public static void requireNotEmpty(String annotation, String str) {\n        var msg = format(\"Require [%s] cannot be empty\", annotation);\n        recordContract(msg);\n        requireImpl(msg, () -> !str.isEmpty());\n    }\n\n    /**\n     * Check a post-condition.\n     *\n     * @param annotation the description of the post-condition\n     * @param assertion  a lambda expression to represent the assertion\n     *                   of the post-condition\n     * @throws PostconditionViolationException\n     *          if the {@code assertion} returns {@code false}\n     */\n    public static void ensure(String annotation, BooleanSupplier assertion) {\n        var msg = format(\"Ensure %s\", annotation);\n        recordContract(msg);\n        ensureImpl(msg, assertion);\n    }\n\n    /**\n     * Check a post-condition of an object cannot be {@code null}.\n     *\n     * @param annotation the description of the post-condition\n     * @param obj        the object\n     * @throws PostconditionViolationException\n     *          if the {@code obj} is {@code null}\n     */\n    public static void ensureNotNull(String annotation, Object obj){\n        var msg = format(\"Ensure [%s] cannot be null\", annotation);\n        recordContract(msg);\n        ensureImpl(msg, () -> null != obj);\n    }\n\n    /**\n     * Check a post-condition and return {@code result}.\n     *\n     * @param <T>         the type of {@code result}\n     * @param annotation  the description of the post-condition\n     * @param result      the returning result\n     * @param assertion   a lambda expression that accepts the {@code result}\n     *                    to represent the assertion of the post-condition\n     * @return the {@code result} if the {@code assertion} is {@code true}\n     * @throws PostconditionViolationException\n     *          if the {@code assertion} is {@code false}\n     */\n    public static <T> T ensureResult(String annotation, T result, Function<T, Boolean> assertion) {\n        var msg = format(\"Ensure result [%s]\", annotation);\n        recordContract(msg);\n        return ensureResultImpl(msg, result, assertion);\n    }\n\n    /**\n     * Check if {@code resultingCollection} is immutable in post-condition.\n     *\n     * @param <T>                 the type of {@code resultingCollection}\n     * @param resultingCollection the returning Collection\n     * @return the {@code resultingCollection} if it is immutable\n     * @throws PostconditionViolationException\n     *          if {@code resultingCollection} is not immutable\n     */\n    public static <T> T ensureImmutableCollection(T resultingCollection) {\n        var msg = format(\"Ensure resultingCollection is an immutable collection\");\n        recordContract(msg);\n        return ensureResultImpl(msg, resultingCollection, x -> x.getClass().getSimpleName().startsWith(\"Unmodifiable\") || x.getClass().getSimpleName().startsWith(\"ListN\"));\n    }\n\n    /**\n     * Check the fields except for {@code assignables} are not changed.\n     *\n     * @param <T> the type of {@code state} and {@code oldState}\n     * @param state the object after changing state\n     * @param oldState the object before changing state\n     * @param assignables regular expressions for name of the fields that can be changed\n     * @throws PostconditionViolationException\n     *          if any field not assignable is changed\n     */\n    public static <T> void ensureAssignable(T state, T oldState, String ... assignables) {\n        var msg = \"\";\n        recordContract(msg);\n        ensureImpl(msg, () -> {\n            try {\n                assertThat(state)\n                        .usingRecursiveComparison()\n                        .ignoringFieldsMatchingRegexes(assignables)\n                        .isEqualTo(oldState);\n            } catch (AssertionError e) {\n                throw new PostconditionViolationException(e.getMessage());\n            }\n            return true;\n        });\n    }\n\n    /**\n     * Check a class invariant.\n     *\n     * @param annotation  the description of the class invariant\n     * @param assertion   a lambda expression to represent the assertion\n     *                    of the class invariant\n     * @throws ClassInvariantViolationException\n     *          if the {@code assertion} is {@code false}\n     */\n    public static void invariant(String annotation, BooleanSupplier assertion) {\n        var msg = format(\"Ensure Invariant [%s]\", annotation);\n        recordContract(msg);\n        invariantImpl(msg, assertion);\n    }\n\n    /**\n     * Check a class invariant of an object cannot be {@code null}.\n     *\n     * @param annotation the description of the class invariant\n     * @param obj        the object\n     * @throws ClassInvariantViolationException\n     *          if the {@code obj} is {@code null}\n     */\n    public static void invariantNotNull(String annotation, Object obj) {\n        var msg = format(\"Invariant [%s] cannot be null\", annotation);\n        recordContract(msg);\n        invariantImpl(msg, () -> null != obj);\n    }\n\n    /**\n     * Return the boolean value of the assertion to tell the caller\n     * whether to reject the operation and return immediately.\n     *\n     * @param annotation the description of the rejection\n     * @param assertion  a lambda expression to represent the assertion\n     *                   for rejection\n     * @return {@code true} when the caller have to reject the operation.\n     */\n    public static boolean reject(String annotation, BooleanSupplier assertion) {\n        recordContract(format(\"Reject %s\", annotation));\n        return assertion.getAsBoolean();\n    }\n\n    /**\n     * To represent the semantic of <b>imply</b>.\n     * {@code a} implies {@code b} means that if {@code a} is {@code true}\n     * then {@code b} is {@code true}.\n     *\n     * @param a the lambda expression to represent the assertion\n     * @param b the lambda expression to represent the assertion\n     * @return {@code true} when {@code a} implies {@code b}\n     */\n    public static boolean imply(BooleanSupplier a, BooleanSupplier b) {\n        return !a.getAsBoolean() || b.getAsBoolean();\n    }\n\n    /**\n     * To represent the semantic of <b>follows from</b>.\n     * {@code a} follows from {@code b} means that if {@code b} is {@code true}\n     * then {@code a} is {@code true}.\n     *\n     * @param a the lambda expression to represent the assertion\n     * @param b the lambda expression to represent the assertion\n     * @return {@code true} when {@code a} follows from {@code b}\n     */\n    public static boolean followsFrom(BooleanSupplier a, BooleanSupplier b) {\n        return a.getAsBoolean() || !b.getAsBoolean();\n    }\n\n    /**\n     * To represent the semantic of {@code a} <b>if and only if</b> {@code b}.\n     * {@code a} if and only if {@code b} means that\n     * {@code a} is {@code true} if {@code b} is {@code true}, and\n     * {@code b} is {@code true} if {@code a} is {@code true}.\n     *\n     * @param a the lambda expression to represent the assertion\n     * @param b the lambda expression to represent the assertion\n     * @return {@code true} when {@code a} if and only if {@code b}\n     */\n    public static boolean ifAndOnlyIf(BooleanSupplier a, BooleanSupplier b) {\n        var aResult = a.getAsBoolean();\n        var bResult = b.getAsBoolean();\n        return (aResult && bResult) || (!aResult && !bResult);\n    }\n\n    /**\n     * Denote the value that supplier has which is used in post-conditions.\n     *\n     * @param <T> the type of object that {@code supplier} provides\n     * @param supplier a lambda expression provides an object\n     * @return a deep copy of the object provided by {@code supplier}\n     */\n    public static <T> T old(Supplier<T> supplier) {\n        if (!CHECK_POST) {\n            return null;\n        }\n        if (isCalledByAssertion(1)) {\n            return null;\n        }\n        var json = asBytes(supplier.get());\n        return (T) readJsonAs(json, supplier.get().getClass());\n    }\n\n    private static <T> T ensureResultImpl(String annotation, T returnValue, Function<T, Boolean> assertion) {\n        if (!CHECK_POST) return returnValue;\n        if (isCalledByAssertion(2)) {\n            return returnValue;\n        }\n        if (assertion.apply(returnValue)) return returnValue;\n        throw new PostconditionViolationException(annotation);\n    }\n\n    private static void ensureImpl(String annotation, BooleanSupplier assertion) {\n        if (!CHECK_POST)\n            return;\n        if (isCalledByAssertion(2)) {\n            return;\n        }\n        if (!assertion.getAsBoolean()) {\n            throw new PostconditionViolationException(annotation);\n        }\n    }\n\n    private static void invariantImpl(String annotation, BooleanSupplier assertion) {\n        if (!CHECK_INV)\n            return;\n        if (isCalledByAssertion(2)) {\n            return;\n        }\n        if (!assertion.getAsBoolean()) {\n            throw new ClassInvariantViolationException(annotation);\n        }\n    }\n\n    private static void checkImpl(String annotation, BooleanSupplier assertion) {\n        if (!CHECK_CHECK)\n            return;\n        if (isCalledByAssertion(2)) {\n            return;\n        }\n        if (!assertion.getAsBoolean()) {\n            throw new CheckViolationException(annotation);\n        }\n    }\n\n    private static void requireImpl(String annotation, BooleanSupplier assertion) {\n        if (!CHECK_PRE)\n            return;\n        if (isCalledByAssertion(2)) {\n            return;\n        }\n        if (!assertion.getAsBoolean()) {\n            throw new PreconditionViolationException(annotation);\n        }\n    }\n\n    private static void recordContract(String newContract) {\n        if (!GENERATE_DOC) return;\n\n        final StackWalker.StackFrame stack = StackWalker.getInstance()\n                .walk(s -> s.limit(3).skip(2).collect(Collectors.toList())).get(0);\n        String key = stack.getClassName() + \"::\" + stack.getMethodName();\n\n        if (runtime.containsKey(key)){\n            for(var existingContract : runtime.get(key)){\n                if (isDuplicatedContract(existingContract, newContract))\n                    return;\n            }\n            runtime.get(key).add(newContract);\n        }else{\n            runtime.put(key, new ArrayList<>());\n            runtime.get(key).add(newContract);\n        }\n    }\n\n\n    private static boolean isDuplicatedContract(String str1, String str2){\n        return eraseArguments(str1).equals(eraseArguments(str2));\n    }\n\n\n    private static String eraseArguments(String runtimeContract){\n        String regular = \"'[^\\\\\\\\s']*'\";\n        Pattern pattern = Pattern.compile(regular);\n        Matcher matcher = pattern.matcher(runtimeContract);\n        List<String> foundTokens = new ArrayList<>();\n        while (matcher.find()) {\n            foundTokens.add(matcher.group(0));\n        }\n        for(var each : foundTokens){\n            runtimeContract = runtimeContract.replace(each, \"\");\n        }\n        return runtimeContract;\n    }\n\n    private static boolean isCalledByAssertion(int NumberOfStacksInCurrentAssertion) {\n        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();\n        var contractClass = stackTraceElements[1].getClassName();\n        final int NUMBER_OF_STACK_OF_THIS_METHOD = 1;\n        var totalNumbersContractsOfStacks = Arrays.stream(stackTraceElements).filter(x -> x.getClassName().equals(contractClass)).toList().size();\n        if ((totalNumbersContractsOfStacks - NUMBER_OF_STACK_OF_THIS_METHOD) > NumberOfStacksInCurrentAssertion) {\n            return true;\n        }\n        return false;\n    }\n\n    private static byte[] asBytes(Object value){\n        try {\n            return mapper.writeValueAsBytes(value);\n        } catch (JsonProcessingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static <A> A readJsonAs(byte[] content, Class<A> clazz) {\n\n        try {\n            return mapper.readValue(content, clazz);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n這是 uContract 專案中的 `Contract` 類別，提供了一種強大的方式來實現設計合約（Design by Contract）原則。讓我來分析這個類別的主要功能和用法：\n\n### Contract 類別概述\n\n這個類別為程式碼提供了前置條件（preconditions）、後置條件（postconditions）和類別不變量（class invariants）的檢查機制，這是設計合約編程的核心原則。\n\n### 主要特點：\n\n1. **設計合約檢查控制**：\n   - 提供多個靜態布林變數（如 `DBC`, `CHECK_PRE`, `CHECK_POST`, `CHECK_INV`）來控制是否啟用不同類型的合約檢查\n   - 可以通過環境變數來配置這些開關（如 `DBC=off`）\n\n2. **前置條件檢查**：\n   - `require(String, BooleanSupplier)`: 檢查方法執行前必須滿足的條件\n   - `requireNotNull(String, Object)`: 檢查對象不為空\n   - `requireNotEmpty(String, String)`: 檢查字符串不為空\n\n3. **後置條件檢查**：\n   - `ensure(String, BooleanSupplier)`: 檢查方法執行後必須滿足的條件\n   - `ensureNotNull(String, Object)`: 檢查返回對象不為空\n   - `ensureResult(String, T, Function<T, Boolean>)`: 檢查返回值滿足特定條件\n   - `ensureImmutableCollection(T)`: 檢查返回的集合是不可變的\n   - `ensureAssignable(T, T, String...)`: 檢查只有指定的字段發生了變化\n\n4. **類別不變量檢查**：\n   - `invariant(String, BooleanSupplier)`: 檢查對象必須保持的不變條件\n   - `invariantNotNull(String, Object)`: 檢查對象的特定屬性不為空\n\n5. **邏輯操作輔助**：\n   - `imply(BooleanSupplier, BooleanSupplier)`: 實現邏輯蘊涵（if...then）\n   - `followsFrom(BooleanSupplier, BooleanSupplier)`: 實現反向邏輯蘊涵\n   - `ifAndOnlyIf(BooleanSupplier, BooleanSupplier)`: 實現雙向邏輯蘊涵（if and only if）\n\n6. **功能特性**：\n   - `old(Supplier<T>)`: 在後置條件中引用方法執行前的狀態值\n   - `reject(String, BooleanSupplier)`: 提供拒絕操作的條件檢查\n   - `check(String, BooleanSupplier)`: 提供通用的條件檢查\n   - `checkUnsupportedOperation(Runnable)`: 檢查操作是否不被支持\n\n7. **文檔生成**：\n   - 能夠記錄合約信息，並可選擇性地生成文檔\n\n### 與 EsAggregateRoot 的結合使用\n\n這個 `Contract` 類別與 `EsAggregateRoot` 結合使用時，可以：\n\n1. 在 `ensureInvariant()` 方法中使用 `invariant()` 來定義聚合根的業務規則和不變條件\n2. 在命令處理方法中使用 `require()` 來驗證輸入參數\n3. 在事件處理方法 `when()` 中使用 `ensure()` 來確保狀態變更符合預期\n4. 使用 `old()` 來比較事件應用前後的狀態變化\n\n### 優點\n\n1. **提高代碼質量**：明確定義和檢查合約，使代碼更加健壯\n2. **自文檔化**：合約描述了方法的預期行為和限制\n3. **錯誤檢測**：在早期階段檢測出違反合約的情況\n4. **可配置性**：可以根據環境（開發、測試、生產）調整合約檢查的嚴格程度\n\n這個類別為事件溯源的聚合根提供了強大的合約檢查機制，有助於確保聚合根的完整性和正確性。通過明確定義前置條件、後置條件和不變量，可以使聚合根的行為更加可預測和可靠。\nCard 這個 class 是 card aggregate root，並使用 uContract 定義好所有 methods 的 precondition, postcondition，並在 ensureInvariant 中定義好 aggregate invariants。\nCard class如下：\n```\n\npublic class Card extends EsAggregateRoot<CardId, CardEvents> {\n\n    public final static String CATEGORY = \"Card\";\n\n    public Card(BoardId boardId, WorkflowId workflowId, LaneId laneId, CardId cardId, String description,\n                String estimate, String note, Instant deadline, CardType type, int order, String userId, Set<RelatedCard> relatedCards) {\n        super();\n        requireNotNull(\"Board id\", boardId);\n        requireNotNull(\"Workflow id\", workflowId);\n        requireNotNull(\"Lane id\", laneId);\n        requireNotNull(\"Card id\", cardId);\n        requireNotNull(\"description\", description);\n        requireNotNull(\"card type\", type);\n        require(format(\"card expected order %d be non negative\", order), () -> order >= 0);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        requireNotNull(\"related cards\", relatedCards);\n\n        ensure(format(\"Card's card id is '%s'\", cardId.id()), () -> cardId.equals(getCardId()));\n        ensure(format(\"Card's board id is '%s'\", boardId.id()), () -> boardId.equals(getBoardId()));\n        ensure(format(\"Card's workflow id is '%s'\", workflowId.id()), () -> workflowId.equals(getWorkflowId()));\n        ensure(format(\"Card's lane id is '%s'\", laneId.id()), () -> laneId.equals(getLaneId()));\n        ensure(format(\"Card's description is '%s'\", description), () -> description.equals(getDescription()));\n        ensure(format(\"Card's estimate is '%s'\", estimate), () -> estimate.equals(getEstimate()));\n        ensure(format(\"Card's note is '%s'\", note), () -> note.equals(getNote()));\n        ensure(format(\"Card's deadline is '%s'\", deadline), () -> null == deadline ? null == getDeadline() : deadline.equals(getDeadline()));\n        ensure(format(\"Card's type is '%s'\", type.name()), () -> type.equals(getType()));\n        ensure(format(\"Card's user id is '%s'\", userId), () -> userId.equals(getUserId()));\n        ensure(format(\"Card's related cards is '%s'\", relatedCards), () -> relatedCards.equals(getRelatedCards()));\n        ensure(format(\"Card id '%s' equals aggregate id '%s'\", getCardId(), getId()), ()-> getCardId().equals(getId()));\n        ensureNotNull(\"blockers\", this.blockers);\n        ensure(\"Blockers size is 0\", () -> this.blockers.size() == 0);\n        ensure(\"Tag ids size is 0\", () -> getTagIds().size() == 0);\n        ensureNotNull(\"Assignees\", getAssignees());\n        ensure(\"Assignees size is 0\", () -> getAssignees().size() == 0);\n        ensure(\"a correct CardCreated event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardCreated(boardId, workflowId, laneId, cardId, description, estimate, note, deadline, type, order, userId, relatedCards, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n        ensure(\"Card events aggregate id equals to card id\", () -> getLastDomainEvent().aggregateId().equals(getCardId().id()));\n    }\n    //endregion\n\n    //region :Behaviors\n    public void markAsDeleted(String userId) {\n        require(\"Card is not deleted\", () -> !isDeleted());\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        ensure(\"Card is marked as deleted\", () -> isDeleted());\n        ensure(\"a correct CardDeleted event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDeleted(getBoardId(), getWorkflowId(), getLaneId(), getCardId(), userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public boolean isDeleted() {\n        return ensureResult(\"result should be correct\", result, result -> result == this.isDeleted);\n    }\n\n    @Override\n    public String getCategory() {\n        return CATEGORY;\n    }\n\n    public void changeDescription(String newDescription, String userId) {\n        requireNotNull(\"new description\", newDescription);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if (reject(\"same description\", () -> newDescription.equals(getDescription()))) return;\n\n        ensure(format(\"Card's description is '%s'\", newDescription), ()-> getDescription().equals(newDescription));\n        ensure(\"a correct CardDescriptionChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDescriptionChanged(getBoardId(), getWorkflowId(), getCardId(), newDescription, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeEstimate(String newEstimate, String userId) {\n        requireNotNull(\"new estimate\", newEstimate);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same estimate\", () -> newEstimate.equals(getEstimate())))  return;\n\n        ensure(format(\"Card's estimate is '%s'\", newEstimate), ()-> getEstimate().equals(newEstimate));\n        ensure(\"a correct CardEstimateChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardEstimateChanged(getBoardId(), getWorkflowId(), getCardId(), newEstimate, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeNote(String newNote, String userId) {\n        requireNotNull(\"New note\", newNote);\n        requireNotEmpty(\"New note\", newNote);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        ensure(format(\"Card's note is '%s'\", newNote), () -> newNote.equals(getNote()));\n        ensure(\"a correct CardNoteChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardNoteChanged(getBoardId(), getWorkflowId(), getCardId(), newNote, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n\n    }\n\n    public void changeType(CardType newType, String userId) {\n        requireNotNull(\"New type\", newType);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same type\", () -> newType.equals(getType()))) return;\n\n        ensure(format(\"Card's type is '%s'\", newType.name()), () -> newType.equals(getType()));\n        ensure(\"a correct CardTypeChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardTypeChanged(getBoardId(), getWorkflowId(), getCardId(), newType, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeDeadline(Instant newDeadline, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same deadline\", () -> null == getDeadline() ? null == newDeadline : getDeadline().equals(newDeadline))) return;\n\n        ensure(format(\"Card's deadline is '%s'\", newDeadline), ()-> null == newDeadline ? null == getDeadline() : getDeadline().equals(newDeadline));\n        ensure(\"a correct CardDeadlineChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDeadlineChanged(getBoardId(), getWorkflowId(), getCardId(), newDeadline, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public CardId getCardId() {\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.cardId));\n    }\n\n    @Override\n    public String getDescription() {\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.description));\n    }\n\n    public String getEstimate() {\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.estimate));\n    }\n\n    public String getNote() {\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.note));\n    }\n\n    @Override\n    public Instant getDeadline() {\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.deadline));\n    }\n\n    public CardType getType() {\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.type));\n    }\n\n    public void move(WorkflowId workflowId, LaneId newLaneId, String userId, int newOrder) {\n        requireNotNull(\"Workflow id\", workflowId);\n        requireNotNull(\"Lane id\", newLaneId);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        require(\"Order >= 0\", () -> newOrder >= 0);\n\n        LaneId oldLaneId = old(() -> getLaneId());\n\n        ensure(format(\"Workflow id is '%s'\", workflowId), () -> getWorkflowId().equals(workflowId));\n        ensure(format(\"Lane id is '%s'\", newLaneId), () -> getLaneId().equals(newLaneId));\n        ensure(\"a correct CardMoved event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardMoved(getBoardId(), getWorkflowId(), getCardId(), oldLaneId, newLaneId, newOrder, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public BoardId getBoardId() {\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.boardId));\n    }\n\n    public WorkflowId getWorkflowId() {\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.workflowId));\n    }\n\n    public LaneId getLaneId() {\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.laneId));\n    }\n\n    public String getUserId() {\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.userId));\n    }\n\n    public void block(BlockerId blockerId, String blockerName, String blockReason, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        requireNotNull(\"blocker id\", blockerId);\n        requireNotNull(\"blocker name\", blockerName);\n        requireNotNull(\"blocker name\", blockerName);\n        requireNotEmpty(\"blocker name\", blockerName);\n        requireNotNull(\"blocker reason\", blockReason);\n        require(\"Card has not been blocked\", () -> !isBlocked());\n\n        ensure(\"Card is blocked\", () -> isBlocked());\n        ensure(format(\"Blocker id is '%s'\", blockerId), () -> getBlocker().get().getId().equals(blockerId));\n        ensure(format(\"Blocker name is '%s'\", blockerName), () -> getBlocker().get().getName().equals(blockerName));\n        ensure(format(\"Blocker reason is '%s'\", blockReason), () -> getBlocker().get().getBlockReason().equals(blockReason));\n        ensure(\"a correct CardBlocked event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardBlocked(getBoardId(), getWorkflowId(), getCardId(), blockerId, blockerName, blockReason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void unblock(String reason, String userId) {\n        requireNotNull(\"unblock reason\", reason);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        require(\"card has been blocked\", () -> isBlocked());\n\n        Blocker oldBlocker = old(() -> getBlocker().get());\n\n        ensure(\"card is unblocked\", () -> !isBlocked());\n        ensure(\"unblocker is in blocker list\", () -> this.blockers.stream().anyMatch(x-> x.getId().equals(oldBlocker.getId())));\n        ensure(format(\"unblock reason is '%s'\", reason), () -> this.blockers.stream().anyMatch(x-> x.getId().equals(oldBlocker.getId()) && x.getUnblockReason().equals(reason)));\n        ensure(\"unblocked blocker's end date is correct\", () -> getUnblockers().get(getUnblockers().size()-1).getEndDate().equals(getLastDomainEvent().occurredOn()));\n        ensure(\"a correct CardUnblocked event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardUnblocked(getBoardId(), getWorkflowId(), getCardId(), oldBlocker.getId(), reason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    // TODO removed unused returning blocker id.\n//    public BlockerId changeBlockerReason(String reason, String userId) {\n    public void changeBlockerReason(String reason, String userId) {\n        requireNotNull(\"block reason\", reason);\n        requireNotNull(\"user id\", userId);\n        require(\"Card is blocked\", () -> isBlocked());\n\n        ensure(\"Card is blocked\", () -> isBlocked());\n        ensure(format(\"Block reason is '%s'\", reason), () -> getBlocker().get().getBlockReason().equals(reason));\n        ensure(\"a correct BlockerReasonChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.BlockerReasonChanged(getBoardId(), getWorkflowId(), getCardId(), getBlocker().get().getId(), reason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public Optional<Blocker> getBlocker() {\n        return ensureResult(\"result is correct\", result,\n                result ->\n                        result.map(blocker -> blocker.isBlocked())\n                            .orElse(() -> this.blockers.stream().noneMatch(x->x.getStatus().equals(BlockerStatus.Block))));\n    }\n\n    public boolean isBlocked() {\n        return ensureResult(\"result is correct\", result, result->result == getBlocker().isPresent());\n    }\n\n    public List<Blocker> getUnblockers() {\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public void assignUsers(List<String> assigneeIds, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotNull(\"assignee ids\", assigneeIds);\n        require(\"users are not assigned\", () -> _users_are_not_assigned(assigneeIds));\n        require(\"list of user id to be assigned cannot be empty\", () -> !assigneeIds.isEmpty());\n\n        var oldDomainEventsSize = old(() -> getDomainEventSize());\n\n        ensure(\"users are assigned to assignee list\", () -> _users_are_assigned(assigneeIds));\n        ensure(format(\"size of domain event increased by %d\", assigneeIds.size()), () -> assigneeIds.size() == (getDomainEventSize() - oldDomainEventsSize));\n        ensure(\"all CardAssigned events are correctly generated\", () -> _check_card_assigned_events(assigneeIds, userId));\n    }\n\n\n    public void unassignUsers(List<String> unassigneeIds, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotNull(\"unassignee ids\", unassigneeIds);\n        require(\"users are assigned\", () -> _users_are_assigned(unassigneeIds));\n        require(\"list of user id to be assigned cannot be empty\", () -> !unassigneeIds.isEmpty());\n\n        var oldDomainEventsSize = old(() -> getDomainEventSize());\n\n        ensure(\"users are unassigned from assignee list\", () -> _users_are_not_assigned(unassigneeIds));\n        ensure(format(\"size of domain event increased by %d\", unassigneeIds.size()), () -> unassigneeIds.size() == (getDomainEventSize() - oldDomainEventsSize));\n        ensure(\"all CardUnassigned events are correctly generated\", () -> _check_card_unassigned_events(unassigneeIds, userId));\n    }\n\n    public List<Assignee> getAssignees() {\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public Optional<Assignee> getAssignee(String assigneeId) {\n        return ensureResult(\"result is correct\", result,\n                result ->\n                result.map(assignee->assignee.userId().equals(assigneeId))\n                        .orElse(this.assignees.stream().noneMatch(assignee -> assignee.userId().equals(assigneeId))));\n    }\n\n    public void assignTag(TagId tagId, String userId) {\n        requireNotNull(\"Tag id\", tagId);\n        requireNotNull(\"User id\", userId);\n        require(format(\"Tag is not assigned\", tagId), ()-> !getTagIds().contains(tagId));\n\n        ensure(format(\"Tag '%s' is assigned to card '%s'\", tagId, getCardId()), ()-> getTagIds().contains(tagId));\n        ensure(\"a correct TagAssigned event is generated\", () -> getLastDomainEvent().equals(new CardEvents.TagAssigned(getBoardId(), getWorkflowId(), getCardId(), tagId, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void unassignTag(TagId tagId, String userId) {\n        requireNotNull(\"Tag id\", tagId);\n        requireNotNull(\"User id\", userId);\n        require(format(\"Tag '%s' has been assigned to the card '%s'\", tagId, getCardId()), ()-> getTagIds().contains(tagId));\n\n        ensure(format(\"Tag '%s' is unassigned from card '%s'\", tagId, getCardId()), ()-> !getTagIds().contains(tagId));\n        ensure(\"a correct TagUnassigned event is generated\", () -> getLastDomainEvent().equals(new CardEvents.TagUnassigned(getBoardId(), getWorkflowId(), getCardId(), tagId, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public Set<TagId> getTagIds() {\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public Set<RelatedCard> getRelatedCards() {\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public void attachChild(String childCardId, String userId) {\n        requireNotNull(\"ChildCard id\", childCardId);\n        requireNotNull(\"User id\", userId);\n\n        ensure(format(\"ChildCard id '%s' is attached to ParentCard id '%s'\", childCardId, getCardId()), ()-> getRelatedCards().stream().anyMatch(x->x.relatedCardId().id().equals(childCardId)));\n        ensure(\"a correct ChildAttached event is generated\", () -> getLastDomainEvent().equals(new CardEvents.ChildAttached(getBoardId(), getWorkflowId(), getCardId(), CardId.valueOf(childCardId), userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    @Override\n    public CardId getId() {\n        return getCardId();\n    }\n\n    //endregion\n\n    protected void ensureInvariant() {\n        invariant(\"is not marked as deleted\", () -> !isDeleted());\n        invariantNotNull(\"Board id\", getBoardId());\n        invariantNotNull(\"Workflow id\", getWorkflowId());\n        invariantNotNull(\"Lane id\", getLaneId());\n        invariantNotNull(\"Card id\", getCardId());\n        invariant(format(\"CATEGORY '%s'\", getCategory()), () -> getCategory().equals(CATEGORY));\n    }\n\n    private boolean _users_are_not_assigned(List<String> assigneeIds) {\n        for(String assigneeId: assigneeIds){\n            if(getAssignees().stream().anyMatch(x->x.userId().equals(assigneeId))){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean _users_are_assigned(List<String> assigneeIds) {\n        for (String assigneeId : assigneeIds) {\n            var assignee = getAssignees().stream().filter(x -> x.userId().equals(assigneeId)).findFirst();\n            if (assignee.isEmpty()) {\n                return false;\n            }\n            if (null == assignee.get().cardId()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean _check_card_assigned_events(List<String> assigneeIds, String userId) {\n        try {\n            int i = getDomainEventSize() - assigneeIds.size();\n            for (String each : assigneeIds) {\n                if (!getDomainEvents().get(i).equals(new CardEvents.CardAssigned(\n                        getBoardId(),\n                        getWorkflowId(),\n                        getCardId(),\n                        each,\n                        userId,\n                        getDomainEvents().get(i).id(),\n                        getDomainEvents().get(i).occurredOn()))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n\n    private boolean _check_card_unassigned_events(List<String> unassigneeIds, String userId) {\n        try {\n            int i = getDomainEventSize() - unassigneeIds.size();\n            for (String each : unassigneeIds) {\n                if (!getDomainEvents().get(i).equals(new CardEvents.CardUnassigned(\n                        getBoardId(),\n                        getWorkflowId(),\n                        getCardId(),\n                        each,\n                        userId,\n                        getDomainEvents().get(i).id(),\n                        getDomainEvents().get(i).occurredOn()))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n```\n\nCardEvents介面如下：\n```\npublic interface CardEvents extends DomainEvent {\n\n    BoardId boardId();\n\n    WorkflowId workflowId();\n\n    CardId cardId();\n\n    default String aggregateId() {\n        return cardId().id();\n    }\n}\n```\n\n請根據 EsAggregateRoot的設計以及定義好的合約，將Card aggregate root 完成。\n為了完成 Card 聚合根的實作，我需要基於提供的程式碼，結合 EsAggregateRoot 和 uContract 的設計理念，完善這個類別。\n\n以下是完整的 Card 聚合根實作：\n\n```java\npublic class Card extends EsAggregateRoot<CardId, CardEvents> {\n\n    public final static String CATEGORY = \"Card\";\n    \n    // 聚合根的狀態屬性\n    private CardId cardId;\n    private BoardId boardId;\n    private WorkflowId workflowId;\n    private LaneId laneId;\n    private String description;\n    private String estimate;\n    private String note;\n    private Instant deadline;\n    private CardType type;\n    private String userId;\n    private boolean isDeleted;\n    private List<Blocker> blockers;\n    private List<Assignee> assignees;\n    private Set<TagId> tagIds;\n    private Set<RelatedCard> relatedCards;\n    \n    // 用於返回不可變集合的暫存變數\n    private transient List<Blocker> resultingCollection;\n    private transient List<Assignee> resultingCollection;\n    private transient Set<TagId> resultingCollection;\n    private transient Set<RelatedCard> resultingCollection;\n    private transient boolean result;\n    private transient CardId result;\n    private transient BoardId result;\n    private transient WorkflowId result;\n    private transient LaneId result;\n    private transient String result;\n    private transient Instant result;\n    private transient CardType result;\n    private transient Optional<Blocker> result;\n    private transient Optional<Assignee> result;\n\n    // 空構造函數，供事件重播使用\n    protected Card() {\n        super();\n        this.blockers = new ArrayList<>();\n        this.assignees = new ArrayList<>();\n        this.tagIds = new HashSet<>();\n        this.relatedCards = new HashSet<>();\n        this.isDeleted = false;\n    }\n\n    // 主構造函數\n    public Card(BoardId boardId, WorkflowId workflowId, LaneId laneId, CardId cardId, String description,\n                String estimate, String note, Instant deadline, CardType type, int order, String userId, Set<RelatedCard> relatedCards) {\n        super();\n        requireNotNull(\"Board id\", boardId);\n        requireNotNull(\"Workflow id\", workflowId);\n        requireNotNull(\"Lane id\", laneId);\n        requireNotNull(\"Card id\", cardId);\n        requireNotNull(\"description\", description);\n        requireNotNull(\"card type\", type);\n        require(format(\"card expected order %d be non negative\", order), () -> order >= 0);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        requireNotNull(\"related cards\", relatedCards);\n\n        // 初始化屬性\n        this.blockers = new ArrayList<>();\n        this.assignees = new ArrayList<>();\n        this.tagIds = new HashSet<>();\n        \n        // 應用創建事件\n        apply(new CardEvents.CardCreated(boardId, workflowId, laneId, cardId, description, estimate, note, deadline, type, order, userId, relatedCards));\n\n        // 驗證後置條件\n        ensure(format(\"Card's card id is '%s'\", cardId.id()), () -> cardId.equals(getCardId()));\n        ensure(format(\"Card's board id is '%s'\", boardId.id()), () -> boardId.equals(getBoardId()));\n        ensure(format(\"Card's workflow id is '%s'\", workflowId.id()), () -> workflowId.equals(getWorkflowId()));\n        ensure(format(\"Card's lane id is '%s'\", laneId.id()), () -> laneId.equals(getLaneId()));\n        ensure(format(\"Card's description is '%s'\", description), () -> description.equals(getDescription()));\n        ensure(format(\"Card's estimate is '%s'\", estimate), () -> estimate.equals(getEstimate()));\n        ensure(format(\"Card's note is '%s'\", note), () -> note.equals(getNote()));\n        ensure(format(\"Card's deadline is '%s'\", deadline), () -> null == deadline ? null == getDeadline() : deadline.equals(getDeadline()));\n        ensure(format(\"Card's type is '%s'\", type.name()), () -> type.equals(getType()));\n        ensure(format(\"Card's user id is '%s'\", userId), () -> userId.equals(getUserId()));\n        ensure(format(\"Card's related cards is '%s'\", relatedCards), () -> relatedCards.equals(getRelatedCards()));\n        ensure(format(\"Card id '%s' equals aggregate id '%s'\", getCardId(), getId()), ()-> getCardId().equals(getId()));\n        ensureNotNull(\"blockers\", this.blockers);\n        ensure(\"Blockers size is 0\", () -> this.blockers.size() == 0);\n        ensure(\"Tag ids size is 0\", () -> getTagIds().size() == 0);\n        ensureNotNull(\"Assignees\", getAssignees());\n        ensure(\"Assignees size is 0\", () -> getAssignees().size() == 0);\n        ensure(\"a correct CardCreated event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardCreated(boardId, workflowId, laneId, cardId, description, estimate, note, deadline, type, order, userId, relatedCards, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n        ensure(\"Card events aggregate id equals to card id\", () -> getLastDomainEvent().aggregateId().equals(getCardId().id()));\n    }\n\n    // 使用事件列表構造聚合根\n    public Card(List<CardEvents> events) {\n        super(events);\n    }\n\n    // 實作 when 方法，處理各種事件\n    @Override\n    protected void when(CardEvents event) {\n        if (event instanceof CardEvents.CardCreated e) {\n            this.cardId = e.cardId();\n            this.boardId = e.boardId();\n            this.workflowId = e.workflowId();\n            this.laneId = e.laneId();\n            this.description = e.description();\n            this.estimate = e.estimate();\n            this.note = e.note();\n            this.deadline = e.deadline();\n            this.type = e.type();\n            this.userId = e.userId();\n            this.relatedCards = new HashSet<>(e.relatedCards());\n            this.blockers = new ArrayList<>();\n            this.assignees = new ArrayList<>();\n            this.tagIds = new HashSet<>();\n            this.isDeleted = false;\n        } else if (event instanceof CardEvents.CardDeleted) {\n            this.isDeleted = true;\n        } else if (event instanceof CardEvents.CardDescriptionChanged e) {\n            this.description = e.description();\n        } else if (event instanceof CardEvents.CardEstimateChanged e) {\n            this.estimate = e.estimate();\n        } else if (event instanceof CardEvents.CardNoteChanged e) {\n            this.note = e.note();\n        } else if (event instanceof CardEvents.CardTypeChanged e) {\n            this.type = e.type();\n        } else if (event instanceof CardEvents.CardDeadlineChanged e) {\n            this.deadline = e.deadline();\n        } else if (event instanceof CardEvents.CardMoved e) {\n            this.workflowId = e.workflowId();\n            this.laneId = e.newLaneId();\n        } else if (event instanceof CardEvents.CardBlocked e) {\n            Blocker blocker = new Blocker(\n                e.blockerId(),\n                e.blockerName(),\n                e.blockReason(),\n                e.occurredOn(),\n                null,\n                null,\n                BlockerStatus.Block\n            );\n            this.blockers.add(blocker);\n        } else if (event instanceof CardEvents.CardUnblocked e) {\n            this.blockers.stream()\n                .filter(b -> b.getId().equals(e.blockerId()) && b.getStatus().equals(BlockerStatus.Block))\n                .findFirst()\n                .ifPresent(blocker -> {\n                    blocker.setEndDate(e.occurredOn());\n                    blocker.setUnblockReason(e.reason());\n                    blocker.setStatus(BlockerStatus.Unblock);\n                });\n        } else if (event instanceof CardEvents.BlockerReasonChanged e) {\n            this.blockers.stream()\n                .filter(b -> b.getId().equals(e.blockerId()) && b.getStatus().equals(BlockerStatus.Block))\n                .findFirst()\n                .ifPresent(blocker -> blocker.setBlockReason(e.reason()));\n        } else if (event instanceof CardEvents.CardAssigned e) {\n            this.assignees.add(new Assignee(e.assigneeId(), this.cardId));\n        } else if (event instanceof CardEvents.CardUnassigned e) {\n            this.assignees.removeIf(a -> a.userId().equals(e.assigneeId()));\n        } else if (event instanceof CardEvents.TagAssigned e) {\n            this.tagIds.add(e.tagId());\n        } else if (event instanceof CardEvents.TagUnassigned e) {\n            this.tagIds.remove(e.tagId());\n        } else if (event instanceof CardEvents.ChildAttached e) {\n            this.relatedCards.add(new RelatedCard(e.childCardId(), RelationshipType.Child));\n        }\n    }\n    \n    // 業務行為方法\n    public void markAsDeleted(String userId) {\n        require(\"Card is not deleted\", () -> !isDeleted());\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        apply(new CardEvents.CardDeleted(this.boardId, this.workflowId, this.laneId, this.cardId, userId));\n\n        ensure(\"Card is marked as deleted\", () -> isDeleted());\n        ensure(\"a correct CardDeleted event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDeleted(getBoardId(), getWorkflowId(), getLaneId(), getCardId(), userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public boolean isDeleted() {\n        this.result = this.isDeleted;\n        return ensureResult(\"result should be correct\", result, result -> result == this.isDeleted);\n    }\n\n    public void changeDescription(String newDescription, String userId) {\n        requireNotNull(\"new description\", newDescription);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if (reject(\"same description\", () -> newDescription.equals(getDescription()))) return;\n\n        apply(new CardEvents.CardDescriptionChanged(this.boardId, this.workflowId, this.cardId, newDescription, userId));\n\n        ensure(format(\"Card's description is '%s'\", newDescription), ()-> getDescription().equals(newDescription));\n        ensure(\"a correct CardDescriptionChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDescriptionChanged(getBoardId(), getWorkflowId(), getCardId(), newDescription, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeEstimate(String newEstimate, String userId) {\n        requireNotNull(\"new estimate\", newEstimate);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same estimate\", () -> newEstimate.equals(getEstimate())))  return;\n\n        apply(new CardEvents.CardEstimateChanged(this.boardId, this.workflowId, this.cardId, newEstimate, userId));\n\n        ensure(format(\"Card's estimate is '%s'\", newEstimate), ()-> getEstimate().equals(newEstimate));\n        ensure(\"a correct CardEstimateChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardEstimateChanged(getBoardId(), getWorkflowId(), getCardId(), newEstimate, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeNote(String newNote, String userId) {\n        requireNotNull(\"New note\", newNote);\n        requireNotEmpty(\"New note\", newNote);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        apply(new CardEvents.CardNoteChanged(this.boardId, this.workflowId, this.cardId, newNote, userId));\n\n        ensure(format(\"Card's note is '%s'\", newNote), () -> newNote.equals(getNote()));\n        ensure(\"a correct CardNoteChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardNoteChanged(getBoardId(), getWorkflowId(), getCardId(), newNote, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeType(CardType newType, String userId) {\n        requireNotNull(\"New type\", newType);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same type\", () -> newType.equals(getType()))) return;\n\n        apply(new CardEvents.CardTypeChanged(this.boardId, this.workflowId, this.cardId, newType, userId));\n\n        ensure(format(\"Card's type is '%s'\", newType.name()), () -> newType.equals(getType()));\n        ensure(\"a correct CardTypeChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardTypeChanged(getBoardId(), getWorkflowId(), getCardId(), newType, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeDeadline(Instant newDeadline, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same deadline\", () -> null == getDeadline() ? null == newDeadline : getDeadline().equals(newDeadline))) return;\n\n        apply(new CardEvents.CardDeadlineChanged(this.boardId, this.workflowId, this.cardId, newDeadline, userId));\n\n        ensure(format(\"Card's deadline is '%s'\", newDeadline), ()-> null == newDeadline ? null == getDeadline() : getDeadline().equals(newDeadline));\n        ensure(\"a correct CardDeadlineChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDeadlineChanged(getBoardId(), getWorkflowId(), getCardId(), newDeadline, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public CardId getCardId() {\n        this.result = this.cardId;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.cardId));\n    }\n\n    public String getDescription() {\n        this.result = this.description;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.description));\n    }\n\n    public String getEstimate() {\n        this.result = this.estimate;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.estimate));\n    }\n\n    public String getNote() {\n        this.result = this.note;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.note));\n    }\n\n    public Instant getDeadline() {\n        this.result = this.deadline;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.deadline));\n    }\n\n    public CardType getType() {\n        this.result = this.type;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.type));\n    }\n\n    public void move(WorkflowId workflowId, LaneId newLaneId, String userId, int newOrder) {\n        requireNotNull(\"Workflow id\", workflowId);\n        requireNotNull(\"Lane id\", newLaneId);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        require(\"Order >= 0\", () -> newOrder >= 0);\n\n        LaneId oldLaneId = old(() -> getLaneId());\n\n        apply(new CardEvents.CardMoved(this.boardId, workflowId, this.cardId, oldLaneId, newLaneId, newOrder, userId));\n\n        ensure(format(\"Workflow id is '%s'\", workflowId), () -> getWorkflowId().equals(workflowId));\n        ensure(format(\"Lane id is '%s'\", newLaneId), () -> getLaneId().equals(newLaneId));\n        ensure(\"a correct CardMoved event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardMoved(getBoardId(), getWorkflowId(), getCardId(), oldLaneId, newLaneId, newOrder, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public BoardId getBoardId() {\n        this.result = this.boardId;\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.boardId));\n    }\n\n    public WorkflowId getWorkflowId() {\n        this.result = this.workflowId;\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.workflowId));\n    }\n\n    public LaneId getLaneId() {\n        this.result = this.laneId;\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.laneId));\n    }\n\n    public String getUserId() {\n        this.result = this.userId;\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.userId));\n    }\n\n    public void block(BlockerId blockerId, String blockerName, String blockReason, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        requireNotNull(\"blocker id\", blockerId);\n        requireNotNull(\"blocker name\", blockerName);\n        requireNotEmpty(\"blocker name\", blockerName);\n        requireNotNull(\"blocker reason\", blockReason);\n        require(\"Card has not been blocked\", () -> !isBlocked());\n\n        apply(new CardEvents.CardBlocked(this.boardId, this.workflowId, this.cardId, blockerId, blockerName, blockReason, userId));\n\n        ensure(\"Card is blocked\", () -> isBlocked());\n        ensure(format(\"Blocker id is '%s'\", blockerId), () -> getBlocker().get().getId().equals(blockerId));\n        ensure(format(\"Blocker name is '%s'\", blockerName), () -> getBlocker().get().getName().equals(blockerName));\n        ensure(format(\"Blocker reason is '%s'\", blockReason), () -> getBlocker().get().getBlockReason().equals(blockReason));\n        ensure(\"a correct CardBlocked event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardBlocked(getBoardId(), getWorkflowId(), getCardId(), blockerId, blockerName, blockReason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void unblock(String reason, String userId) {\n        requireNotNull(\"unblock reason\", reason);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        require(\"card has been blocked\", () -> isBlocked());\n\n        Blocker oldBlocker = old(() -> getBlocker().get());\n\n        apply(new CardEvents.CardUnblocked(this.boardId, this.workflowId, this.cardId, oldBlocker.getId(), reason, userId));\n\n        ensure(\"card is unblocked\", () -> !isBlocked());\n        ensure(\"unblocker is in blocker list\", () -> this.blockers.stream().anyMatch(x-> x.getId().equals(oldBlocker.getId())));\n        ensure(format(\"unblock reason is '%s'\", reason), () -> this.blockers.stream().anyMatch(x-> x.getId().equals(oldBlocker.getId()) && x.getUnblockReason().equals(reason)));\n        ensure(\"unblocked blocker's end date is correct\", () -> getUnblockers().get(getUnblockers().size()-1).getEndDate().equals(getLastDomainEvent().occurredOn()));\n        ensure(\"a correct CardUnblocked event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardUnblocked(getBoardId(), getWorkflowId(), getCardId(), oldBlocker.getId(), reason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeBlockerReason(String reason, String userId) {\n        requireNotNull(\"block reason\", reason);\n        requireNotNull(\"user id\", userId);\n        require(\"Card is blocked\", () -> isBlocked());\n\n        BlockerId blockerId = getBlocker().get().getId();\n        apply(new CardEvents.BlockerReasonChanged(this.boardId, this.workflowId, this.cardId, blockerId, reason, userId));\n\n        ensure(\"Card is blocked\", () -> isBlocked());\n        ensure(format(\"Block reason is '%s'\", reason), () -> getBlocker().get().getBlockReason().equals(reason));\n        ensure(\"a correct BlockerReasonChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.BlockerReasonChanged(getBoardId(), getWorkflowId(), getCardId(), getBlocker().get().getId(), reason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public Optional<Blocker> getBlocker() {\n        this.result = this.blockers.stream()\n                .filter(b -> b.getStatus().equals(BlockerStatus.Block))\n                .findFirst();\n        return ensureResult(\"result is correct\", result,\n                result ->\n                        result.map(blocker -> blocker.isBlocked())\n                            .orElse(() -> this.blockers.stream().noneMatch(x->x.getStatus().equals(BlockerStatus.Block))));\n    }\n\n    public boolean isBlocked() {\n        this.result = getBlocker().isPresent();\n        return ensureResult(\"result is correct\", result, result->result == getBlocker().isPresent());\n    }\n\n    public List<Blocker> getUnblockers() {\n        this.resultingCollection = this.blockers.stream()\n                .filter(b -> b.getStatus().equals(BlockerStatus.Unblock))\n                .collect(Collectors.toUnmodifiableList());\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public void assignUsers(List<String> assigneeIds, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotNull(\"assignee ids\", assigneeIds);\n        require(\"users are not assigned\", () -> _users_are_not_assigned(assigneeIds));\n        require(\"list of user id to be assigned cannot be empty\", () -> !assigneeIds.isEmpty());\n\n        var oldDomainEventsSize = old(() -> getDomainEventSize());\n\n        for (String assigneeId : assigneeIds) {\n            apply(new CardEvents.CardAssigned(this.boardId, this.workflowId, this.cardId, assigneeId, userId));\n        }\n\n        ensure(\"users are assigned to assignee list\", () -> _users_are_assigned(assigneeIds));\n        ensure(format(\"size of domain event increased by %d\", assigneeIds.size()), () -> assigneeIds.size() == (getDomainEventSize() - oldDomainEventsSize));\n        ensure(\"all CardAssigned events are correctly generated\", () -> _check_card_assigned_events(assigneeIds, userId));\n    }\n\n    public void unassignUsers(List<String> unassigneeIds, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotNull(\"unassignee ids\", unassigneeIds);\n        require(\"users are assigned\", () -> _users_are_assigned(unassigneeIds));\n        require(\"list of user id to be assigned cannot be empty\", () -> !unassigneeIds.isEmpty());\n\n        var oldDomainEventsSize = old(() -> getDomainEventSize());\n\n        for (String unassigneeId : unassigneeIds) {\n            apply(new CardEvents.CardUnassigned(this.boardId, this.workflowId, this.cardId, unassigneeId, userId));\n        }\n\n        ensure(\"users are unassigned from assignee list\", () -> _users_are_not_assigned(unassigneeIds));\n        ensure(format(\"size of domain event increased by %d\", unassigneeIds.size()), () -> unassigneeIds.size() == (getDomainEventSize() - oldDomainEventsSize));\n        ensure(\"all CardUnassigned events are correctly generated\", () -> _check_card_unassigned_events(unassigneeIds, userId));\n    }\n\n    public List<Assignee> getAssignees() {\n        this.resultingCollection = Collections.unmodifiableList(this.assignees);\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public Optional<Assignee> getAssignee(String assigneeId) {\n        this.result = this.assignees.stream().filter(a -> a.userId().equals(assigneeId)).findFirst();\n        return ensureResult(\"result is correct\", result,\n                result ->\n                result.map(assignee->assignee.userId().equals(assigneeId))\n                        .orElse(this.assignees.stream().noneMatch(assignee -> assignee.userId().equals(assigneeId))));\n    }\n\n    public void assignTag(TagId tagId, String userId) {\n        requireNotNull(\"Tag id\", tagId);\n        requireNotNull(\"User id\", userId);\n        require(format(\"Tag is not assigned\", tagId), ()-> !getTagIds().contains(tagId));\n\n        apply(new CardEvents.TagAssigned(this.boardId, this.workflowId, this.cardId, tagId, userId));\n\n        ensure(format(\"Tag '%s' is assigned to card '%s'\", tagId, getCardId()), ()-> getTagIds().contains(tagId));\n        ensure(\"a correct TagAssigned event is generated\", () -> getLastDomainEvent().equals(new CardEvents.TagAssigned(getBoardId(), getWorkflowId(), getCardId(), tagId, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void unassignTag(TagId tagId, String userId) {\n        requireNotNull(\"Tag id\", tagId);\n        requireNotNull(\"User id\", userId);\n        require(format(\"Tag '%s' has been assigned to the card '%s'\", tagId, getCardId()), ()-> getTagIds().contains(tagId));\n\n        apply(new CardEvents.TagUnassigned(this.boardId, this.workflowId, this.cardId, tagId, userId));\n\n        ensure(format(\"Tag '%s' is unassigned from card '%s'\", tagId, getCardId()), ()-> !getTagIds().contains(tagId));\n        ensure(\"a correct TagUnassigned event is generated\", () -> getLastDomainEvent().equals(new CardEvents.TagUnassigned(getBoardId(), getWorkflowId(), getCardId(), tagId, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public Set<TagId> getTagIds() {\n        this.resultingCollection = Collections.unmodifiableSet(this.tagIds);\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public Set<RelatedCard> getRelatedCards() {\n        this.resultingCollection = Collections.unmodifiableSet(this.relatedCards);\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public void attachChild(String childCardId, String userId) {\n        requireNotNull(\"ChildCard id\", childCardId);\n        requireNotNull(\"User id\", userId);\n\n        CardId childId = CardId.valueOf(childCardId);\n        apply(new CardEvents.ChildAttached(this.boardId, this.workflowId, this.cardId, childId, userId));\n\n        ensure(format(\"ChildCard id '%s' is attached to ParentCard id '%s'\", childCardId, getCardId()), ()-> getRelatedCards().stream().anyMatch(x->x.relatedCardId().id().equals(childCardId)));\n        ensure(\"a correct ChildAttached event is generated\", () -> getLastDomainEvent().equals(new CardEvents.ChildAttached(getBoardId(), getWorkflowId(), getCardId(), CardId.valueOf(childCardId), userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    @Override\n    public CardId getId() {\n        return getCardId();\n    }\n\n    @Override\n    public String getCategory() {\n        return CATEGORY;\n    }\n\n    private int getDomainEventSize() {\n        return getDomainEvents().size();\n    }\n\n    private CardEvents getLastDomainEvent() {\n        return getDomainEvents().get(getDomainEvents().size() - 1);\n    }\n\n    @Override\n    protected void ensureInvariant() {\n        invariant(\"is not marked as deleted\", () -> !isDeleted());\n        invariantNotNull(\"Board id\", getBoardId());\n        invariantNotNull(\"Workflow id\", getWorkflowId());\n        invariantNotNull(\"Lane id\", getLaneId());\n        invariantNotNull(\"Card id\", getCardId());\n        invariant(format(\"CATEGORY '%s'\", getCategory()), () -> getCategory().equals(CATEGORY));\n    }\n\n    private boolean _users_are_not_assigned(List<String> assigneeIds) {\n        for(String assigneeId: assigneeIds){\n            if(getAssignees().stream().anyMatch(x->x.userId().equals(assigneeId))){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean _users_are_assigned(List<String> assigneeIds) {\n        for (String assigneeId : assigneeIds) {\n            var assignee = getAssignees().stream().filter(x -> x.userId().equals(assigneeId)).findFirst();\n            if (assignee.isEmpty()) {\n                return false;\n            }\n            if (null == assignee.get().cardId()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean _check_card_assigned_events(List<String> assigneeIds, String userId) {\n        try {\n            int i = getDomainEventSize() - assigneeIds.size();\n            for (String each : assigneeIds) {\n                if (!getDomainEvents().get(i).equals(new CardEvents.CardAssigned(\n                        getBoardId(),\n                        getWorkflowId(),\n                        getCardId(),\n                        each,\n                        userId,\n                        getDomainEvents().get(i).id(),\n                        getDomainEvents().get(i).occurredOn()))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private boolean _check_card_unassigned_events(List<String> unassigneeIds, String userId) {\n        try {\n            int i = getDomainEventSize() - unassigneeIds.size();\n            for (String each : unassigneeIds) {\n                if (!getDomainEvents().get(i).equals(new CardEvents.CardUnassigned(\n                        getBoardId(),\n                        getWorkflowId(),\n                        getCardId(),\n                        each,\n                        userId,\n                        getDomainEvents().get(i).id(),\n                        getDomainEvents().get(i).occurredOn()))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n```\n\n### 實作說明\n\n1. **狀態管理**：\n   - 所有聚合根的狀態資料都定義為類別的屬性\n   - 使用暫存變數（transient）存儲方法返回值，以便進行\n產生各種 domain events 的時候，event id 跟 occurred on 要在呼叫建構元的時候一起作為最後兩個參數 inject \n您是對的，感謝提醒。在建立領域事件時，應該不要自動生成事件 ID 和時間戳，而應該將這些參數明確地傳遞給事件構造函數。\n\n以下是修正後的代碼，確保事件 ID 和時間戳是從呼叫方傳入的：\n\n```java\npublic class Card extends EsAggregateRoot<CardId, CardEvents> {\n\n    public final static String CATEGORY = \"Card\";\n    \n    // 聚合根的狀態屬性\n    private CardId cardId;\n    private BoardId boardId;\n    private WorkflowId workflowId;\n    private LaneId laneId;\n    private String description;\n    private String estimate;\n    private String note;\n    private Instant deadline;\n    private CardType type;\n    private String userId;\n    private boolean isDeleted;\n    private List<Blocker> blockers;\n    private List<Assignee> assignees;\n    private Set<TagId> tagIds;\n    private Set<RelatedCard> relatedCards;\n    \n    // 用於返回不可變集合的暫存變數\n    private transient List<Blocker> resultingCollection;\n    private transient List<Assignee> resultingCollection;\n    private transient Set<TagId> resultingCollection;\n    private transient Set<RelatedCard> resultingCollection;\n    private transient boolean result;\n    private transient CardId result;\n    private transient BoardId result;\n    private transient WorkflowId result;\n    private transient LaneId result;\n    private transient String result;\n    private transient Instant result;\n    private transient CardType result;\n    private transient Optional<Blocker> result;\n    private transient Optional<Assignee> result;\n\n    // 空構造函數，供事件重播使用\n    protected Card() {\n        super();\n        this.blockers = new ArrayList<>();\n        this.assignees = new ArrayList<>();\n        this.tagIds = new HashSet<>();\n        this.relatedCards = new HashSet<>();\n        this.isDeleted = false;\n    }\n\n    // 主構造函數\n    public Card(BoardId boardId, WorkflowId workflowId, LaneId laneId, CardId cardId, String description,\n                String estimate, String note, Instant deadline, CardType type, int order, String userId, Set<RelatedCard> relatedCards) {\n        super();\n        requireNotNull(\"Board id\", boardId);\n        requireNotNull(\"Workflow id\", workflowId);\n        requireNotNull(\"Lane id\", laneId);\n        requireNotNull(\"Card id\", cardId);\n        requireNotNull(\"description\", description);\n        requireNotNull(\"card type\", type);\n        require(format(\"card expected order %d be non negative\", order), () -> order >= 0);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        requireNotNull(\"related cards\", relatedCards);\n\n        // 初始化屬性\n        this.blockers = new ArrayList<>();\n        this.assignees = new ArrayList<>();\n        this.tagIds = new HashSet<>();\n        \n        // 應用創建事件（使用 UUID.randomUUID() 和 Instant.now() 作為預設值）\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardCreated(boardId, workflowId, laneId, cardId, description, estimate, note, deadline, type, order, userId, relatedCards, eventId, occurredOn));\n\n        // 驗證後置條件\n        ensure(format(\"Card's card id is '%s'\", cardId.id()), () -> cardId.equals(getCardId()));\n        ensure(format(\"Card's board id is '%s'\", boardId.id()), () -> boardId.equals(getBoardId()));\n        ensure(format(\"Card's workflow id is '%s'\", workflowId.id()), () -> workflowId.equals(getWorkflowId()));\n        ensure(format(\"Card's lane id is '%s'\", laneId.id()), () -> laneId.equals(getLaneId()));\n        ensure(format(\"Card's description is '%s'\", description), () -> description.equals(getDescription()));\n        ensure(format(\"Card's estimate is '%s'\", estimate), () -> estimate.equals(getEstimate()));\n        ensure(format(\"Card's note is '%s'\", note), () -> note.equals(getNote()));\n        ensure(format(\"Card's deadline is '%s'\", deadline), () -> null == deadline ? null == getDeadline() : deadline.equals(getDeadline()));\n        ensure(format(\"Card's type is '%s'\", type.name()), () -> type.equals(getType()));\n        ensure(format(\"Card's user id is '%s'\", userId), () -> userId.equals(getUserId()));\n        ensure(format(\"Card's related cards is '%s'\", relatedCards), () -> relatedCards.equals(getRelatedCards()));\n        ensure(format(\"Card id '%s' equals aggregate id '%s'\", getCardId(), getId()), ()-> getCardId().equals(getId()));\n        ensureNotNull(\"blockers\", this.blockers);\n        ensure(\"Blockers size is 0\", () -> this.blockers.size() == 0);\n        ensure(\"Tag ids size is 0\", () -> getTagIds().size() == 0);\n        ensureNotNull(\"Assignees\", getAssignees());\n        ensure(\"Assignees size is 0\", () -> getAssignees().size() == 0);\n        ensure(\"a correct CardCreated event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardCreated(boardId, workflowId, laneId, cardId, description, estimate, note, deadline, type, order, userId, relatedCards, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n        ensure(\"Card events aggregate id equals to card id\", () -> getLastDomainEvent().aggregateId().equals(getCardId().id()));\n    }\n\n    // 使用事件列表構造聚合根\n    public Card(List<CardEvents> events) {\n        super(events);\n    }\n\n    // 實作 when 方法，處理各種事件\n    @Override\n    protected void when(CardEvents event) {\n        if (event instanceof CardEvents.CardCreated e) {\n            this.cardId = e.cardId();\n            this.boardId = e.boardId();\n            this.workflowId = e.workflowId();\n            this.laneId = e.laneId();\n            this.description = e.description();\n            this.estimate = e.estimate();\n            this.note = e.note();\n            this.deadline = e.deadline();\n            this.type = e.type();\n            this.userId = e.userId();\n            this.relatedCards = new HashSet<>(e.relatedCards());\n            this.blockers = new ArrayList<>();\n            this.assignees = new ArrayList<>();\n            this.tagIds = new HashSet<>();\n            this.isDeleted = false;\n        } else if (event instanceof CardEvents.CardDeleted) {\n            this.isDeleted = true;\n        } else if (event instanceof CardEvents.CardDescriptionChanged e) {\n            this.description = e.description();\n        } else if (event instanceof CardEvents.CardEstimateChanged e) {\n            this.estimate = e.estimate();\n        } else if (event instanceof CardEvents.CardNoteChanged e) {\n            this.note = e.note();\n        } else if (event instanceof CardEvents.CardTypeChanged e) {\n            this.type = e.type();\n        } else if (event instanceof CardEvents.CardDeadlineChanged e) {\n            this.deadline = e.deadline();\n        } else if (event instanceof CardEvents.CardMoved e) {\n            this.workflowId = e.workflowId();\n            this.laneId = e.newLaneId();\n        } else if (event instanceof CardEvents.CardBlocked e) {\n            Blocker blocker = new Blocker(\n                e.blockerId(),\n                e.blockerName(),\n                e.blockReason(),\n                e.occurredOn(),\n                null,\n                null,\n                BlockerStatus.Block\n            );\n            this.blockers.add(blocker);\n        } else if (event instanceof CardEvents.CardUnblocked e) {\n            this.blockers.stream()\n                .filter(b -> b.getId().equals(e.blockerId()) && b.getStatus().equals(BlockerStatus.Block))\n                .findFirst()\n                .ifPresent(blocker -> {\n                    blocker.setEndDate(e.occurredOn());\n                    blocker.setUnblockReason(e.reason());\n                    blocker.setStatus(BlockerStatus.Unblock);\n                });\n        } else if (event instanceof CardEvents.BlockerReasonChanged e) {\n            this.blockers.stream()\n                .filter(b -> b.getId().equals(e.blockerId()) && b.getStatus().equals(BlockerStatus.Block))\n                .findFirst()\n                .ifPresent(blocker -> blocker.setBlockReason(e.reason()));\n        } else if (event instanceof CardEvents.CardAssigned e) {\n            this.assignees.add(new Assignee(e.assigneeId(), this.cardId));\n        } else if (event instanceof CardEvents.CardUnassigned e) {\n            this.assignees.removeIf(a -> a.userId().equals(e.assigneeId()));\n        } else if (event instanceof CardEvents.TagAssigned e) {\n            this.tagIds.add(e.tagId());\n        } else if (event instanceof CardEvents.TagUnassigned e) {\n            this.tagIds.remove(e.tagId());\n        } else if (event instanceof CardEvents.ChildAttached e) {\n            this.relatedCards.add(new RelatedCard(e.childCardId(), RelationshipType.Child));\n        }\n    }\n    \n    // 業務行為方法\n    public void markAsDeleted(String userId) {\n        require(\"Card is not deleted\", () -> !isDeleted());\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardDeleted(this.boardId, this.workflowId, this.laneId, this.cardId, userId, eventId, occurredOn));\n\n        ensure(\"Card is marked as deleted\", () -> isDeleted());\n        ensure(\"a correct CardDeleted event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDeleted(getBoardId(), getWorkflowId(), getLaneId(), getCardId(), userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public boolean isDeleted() {\n        this.result = this.isDeleted;\n        return ensureResult(\"result should be correct\", result, result -> result == this.isDeleted);\n    }\n\n    public void changeDescription(String newDescription, String userId) {\n        requireNotNull(\"new description\", newDescription);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if (reject(\"same description\", () -> newDescription.equals(getDescription()))) return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardDescriptionChanged(this.boardId, this.workflowId, this.cardId, newDescription, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's description is '%s'\", newDescription), ()-> getDescription().equals(newDescription));\n        ensure(\"a correct CardDescriptionChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDescriptionChanged(getBoardId(), getWorkflowId(), getCardId(), newDescription, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeEstimate(String newEstimate, String userId) {\n        requireNotNull(\"new estimate\", newEstimate);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same estimate\", () -> newEstimate.equals(getEstimate())))  return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardEstimateChanged(this.boardId, this.workflowId, this.cardId, newEstimate, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's estimate is '%s'\", newEstimate), ()-> getEstimate().equals(newEstimate));\n        ensure(\"a correct CardEstimateChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardEstimateChanged(getBoardId(), getWorkflowId(), getCardId(), newEstimate, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeNote(String newNote, String userId) {\n        requireNotNull(\"New note\", newNote);\n        requireNotEmpty(\"New note\", newNote);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardNoteChanged(this.boardId, this.workflowId, this.cardId, newNote, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's note is '%s'\", newNote), () -> newNote.equals(getNote()));\n        ensure(\"a correct CardNoteChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardNoteChanged(getBoardId(), getWorkflowId(), getCardId(), newNote, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeType(CardType newType, String userId) {\n        requireNotNull(\"New type\", newType);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same type\", () -> newType.equals(getType()))) return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardTypeChanged(this.boardId, this.workflowId, this.cardId, newType, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's type is '%s'\", newType.name()), () -> newType.equals(getType()));\n        ensure(\"a correct CardTypeChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardTypeChanged(getBoardId(), getWorkflowId(), getCardId(), newType, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeDeadline(Instant newDeadline, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same deadline\", () -> null == getDeadline() ? null == newDeadline : getDeadline().equals(newDeadline))) return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardDeadlineChanged(this.boardId, this.workflowId, this.cardId, newDeadline, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's deadline is '%s'\", newDeadline), ()-> null == newDeadline ? null == getDeadline() : getDeadline().equals(newDeadline));\n        ensure(\"a correct CardDeadlineChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDeadlineChanged(getBoardId(), getWorkflowId(), getCardId(), newDeadline, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public CardId getCardId() {\n        this.result = this.cardId;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.cardId));\n    }\n\n    public String getDescription() {\n        this.result = this.description;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.description));\n    }\n\n    public String getEstimate() {\n        this.result = this.estimate;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.estimate));\n    }\n\n    public String getNote() {\n        this.result = this.note;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.note));\n    }\n\n    public Instant getDeadline() {\n        this.result = this.deadline;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.deadline));\n    }\n\n    public CardType getType() {\n        this.result = this.type;\n        return ensureResult(\"result should be correct\", result, result -> result.equals(this.type));\n    }\n\n    public void move(WorkflowId workflowId, LaneId newLaneId, String userId, int newOrder) {\n        requireNotNull(\"Workflow id\", workflowId);\n        requireNotNull(\"Lane id\", newLaneId);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        require(\"Order >= 0\", () -> newOrder >= 0);\n\n        LaneId oldLaneId = old(() -> getLaneId());\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardMoved(this.boardId, workflowId, this.cardId, oldLaneId, newLaneId, newOrder, userId, eventId, occurredOn));\n\n        ensure(format(\"Workflow id is '%s'\", workflowId), () -> getWorkflowId().equals(workflowId));\n        ensure(format(\"Lane id is '%s'\", newLaneId), () -> getLaneId().equals(newLaneId));\n        ensure(\"a correct CardMoved event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardMoved(getBoardId(), getWorkflowId(), getCardId(), oldLaneId, newLaneId, newOrder, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public BoardId getBoardId() {\n        this.result = this.boardId;\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.boardId));\n    }\n\n    public WorkflowId getWorkflowId() {\n        this.result = this.workflowId;\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.workflowId));\n    }\n\n    public LaneId getLaneId() {\n        this.result = this.laneId;\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.laneId));\n    }\n\n    public String getUserId() {\n        this.result = this.userId;\n        return ensureResult(\"result is correct\", result, result -> result.equals(this.userId));\n    }\n\n    public void block(BlockerId blockerId, String blockerName, String blockReason, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        requireNotNull(\"blocker id\", blockerId);\n        requireNotNull(\"blocker name\", blockerName);\n        requireNotEmpty(\"blocker name\", blockerName);\n        requireNotNull(\"blocker reason\", blockReason);\n        require(\"Card has not been blocked\", () -> !isBlocked());\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardBlocked(this.boardId, this.workflowId, this.cardId, blockerId, blockerName, blockReason, userId, eventId, occurredOn));\n\n        ensure(\"Card is blocked\", () -> isBlocked());\n        ensure(format(\"Blocker id is '%s'\", blockerId), () -> getBlocker().get().getId().equals(blockerId));\n        ensure(format(\"Blocker name is '%s'\", blockerName), () -> getBlocker().get().getName().equals(blockerName));\n        ensure(format(\"Blocker reason is '%s'\", blockReason), () -> getBlocker().get().getBlockReason().equals(blockReason));\n        ensure(\"a correct CardBlocked event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardBlocked(getBoardId(), getWorkflowId(), getCardId(), blockerId, blockerName, blockReason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void unblock(String reason, String userId) {\n        requireNotNull(\"unblock reason\", reason);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        require(\"card has been blocked\", () -> isBlocked());\n\n        Blocker oldBlocker = old(() -> getBlocker().get());\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardUnblocked(this.boardId, this.workflowId, this.cardId, oldBlocker.getId(), reason, userId, eventId, occurredOn));\n\n        ensure(\"card is unblocked\", () -> !isBlocked());\n        ensure(\"unblocker is in blocker list\", () -> this.blockers.stream().anyMatch(x-> x.getId().equals(oldBlocker.getId())));\n        ensure(format(\"unblock reason is '%s'\", reason), () -> this.blockers.stream().anyMatch(x-> x.getId().equals(oldBlocker.getId()) && x.getUnblockReason().equals(reason)));\n        ensure(\"unblocked blocker's end date is correct\", () -> getUnblockers().get(getUnblockers().size()-1).getEndDate().equals(getLastDomainEvent().occurredOn()));\n        ensure(\"a correct CardUnblocked event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardUnblocked(getBoardId(), getWorkflowId(), getCardId(), oldBlocker.getId(), reason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeBlockerReason(String reason, String userId) {\n        requireNotNull(\"block reason\", reason);\n        requireNotNull(\"user id\", userId);\n        require(\"Card is blocked\", () -> isBlocked());\n\n        BlockerId blockerId = getBlocker().get().getId();\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.BlockerReasonChanged(this.boardId, this.workflowId, this.cardId, blockerId, reason, userId, eventId, occurredOn));\n\n        ensure(\"Card is blocked\", () -> isBlocked());\n        ensure(format(\"Block reason is '%s'\", reason), () -> getBlocker().get().getBlockReason().equals(reason));\n        ensure(\"a correct BlockerReasonChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.BlockerReasonChanged(getBoardId(), getWorkflowId(), getCardId(), getBlocker().get().getId(), reason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public Optional<Blocker> getBlocker() {\n        this.result = this.blockers.stream()\n                .filter(b -> b.getStatus().equals(BlockerStatus.Block))\n                .findFirst();\n        return ensureResult(\"result is correct\", result,\n                result ->\n                        result.map(blocker -> blocker.isBlocked())\n                            .orElse(() -> this.blockers.stream().noneMatch(x->x.getStatus().equals(BlockerStatus.Block))));\n    }\n\n    public boolean isBlocked() {\n        this.result = getBlocker().isPresent();\n        return ensureResult(\"result is correct\", result, result->result == getBlocker().isPresent());\n    }\n\n    public List<Blocker> getUnblockers() {\n        this.resultingCollection = this.blockers.stream()\n                .filter(b -> b.getStatus().equals(BlockerStatus.Unblock))\n                .collect(Collectors.toUnmodifiableList());\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public void assignUsers(List<String> assigneeIds, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotNull(\"assignee ids\", assigneeIds);\n        require(\"users are not assigned\", () -> _users_are_not_assigned(assigneeIds));\n        require(\"list of user id to be assigned cannot be empty\", () -> !assigneeIds.isEmpty());\n\n        var oldDomainEventsSize = old(() -> getDomainEventSize());\n\n        for (String assigneeId : assigneeIds) {\n            UUID eventId = UUID.randomUUID();\n            Instant occurredOn = Instant.now();\n            apply(new CardEvents.CardAssigned(this.boardId, this.workflowId, this.cardId, assigneeId, userId, eventId, occurredOn));\n        }\n\n        ensure(\"users are assigned to assignee list\", () -> _users_are_assigned(assigneeIds));\n        ensure(format(\"size of domain event increased by %d\", assigneeIds.size()), () -> assigneeIds.size() == (getDomainEventSize() - oldDomainEventsSize));\n        ensure(\"all CardAssigned events are correctly generated\", () -> _check_card_assigned_events(assigneeIds, userId));\n    }\n\n    public void unassignUsers(List<String> unassigneeIds, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotNull(\"unassignee ids\", unassigneeIds);\n        require(\"users are assigned\", () -> _users_are_assigned(unassigneeIds));\n        require(\"list of user id to be assigned cannot be empty\", () -> !unassigneeIds.isEmpty());\n\n        var oldDomainEventsSize = old(() -> getDomainEventSize());\n\n        for (String unassigneeId : unassigneeIds) {\n            UUID eventId = UUID.randomUUID();\n            Instant occurredOn = Instant.now();\n            apply(new CardEvents.CardUnassigned(this.boardId, this.workflowId, this.cardId, unassigneeId, userId, eventId, occurredOn));\n        }\n\n        ensure(\"users are unassigned from assignee list\", () -> _users_are_not_assigned(unassigneeIds));\n        ensure(format(\"size of domain event increased by %d\", unassigneeIds.size()), () -> unassigneeIds.size() == (getDomainEventSize() - oldDomainEventsSize));\n        ensure(\"all CardUnassigned events are correctly generated\", () -> _check_card_unassigned_events(unassigneeIds, userId));\n    }\n\n    public List<Assignee> getAssignees() {\n        this.resultingCollection = Collections.unmodifiableList(this.assignees);\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public Optional<Assignee> getAssignee(String assigneeId) {\n        this.result = this.assignees.stream().filter(a -> a.userId().equals(assigneeId)).findFirst();\n        return ensureResult(\"result is correct\", result,\n                result ->\n                result.map(assignee->assignee.userId().equals(assigneeId))\n                        .orElse(this.assignees.stream().noneMatch(assignee -> assignee.userId().equals(assigneeId))));\n    }\n\n    public void assignTag(TagId tagId, String userId) {\n        requireNotNull(\"Tag id\", tagId);\n        requireNotNull(\"User id\", userId);\n        require(format(\"Tag is not assigned\", tagId), ()-> !getTagIds().contains(tagId));\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.TagAssigned(this.boardId, this.workflowId, this.cardId, tagId, userId, eventId, occurredOn));\n\n        ensure(format(\"Tag '%s' is assigned to card '%s'\", tagId, getCardId()), ()-> getTagIds().contains(tagId));\n        ensure(\"a correct TagAssigned event is generated\", () -> getLastDomainEvent().equals(new CardEvents.TagAssigned(getBoardId(), getWorkflowId(), getCardId(), tagId, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void unassignTag(TagId tagId, String userId) {\n        requireNotNull(\"Tag id\", tagId);\n        requireNotNull(\"User id\", userId);\n        require(format(\"Tag '%s' has been assigned to the card '%s'\", tagId, getCardId()), ()-> getTagIds().contains(tagId));\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.TagUnassigned(this.boardId, this.workflowId, this.cardId, tagId, userId, eventId, occurredOn));\n\n        ensure(format(\"Tag '%s' is unassigned from card '%s'\", tagId, getCardId()), ()-> !getTagIds().contains(tagId));\n        ensure(\"a correct TagUnassigned event is generated\", () -> getLastDomainEvent().equals(new CardEvents.TagUnassigned(getBoardId(), getWorkflowId(), getCardId(), tagId, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public Set<TagId> getTagIds() {\n        this.resultingCollection = Collections.unmodifiableSet(this.tagIds);\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public Set<RelatedCard> getRelatedCards() {\n        this.resultingCollection = Collections.unmodifiableSet(this.relatedCards);\n        return ensureImmutableCollection(resultingCollection);\n    }\n\n    public void attachChild(String childCardId, String userId) {\n        requireNotNull(\"ChildCard id\", childCardId);\n        requireNotNull(\"User id\", userId);\n\n        CardId childId = CardId.valueOf(childCardId);\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.ChildAttached(this.boardId, this.workflowId, this.cardId, childId, userId, eventId, occurredOn));\n\n        ensure(format(\"ChildCard id '%s' is attached to ParentCard id '%s'\", childCardId, getCardId()), ()-> getRelatedCards().stream().anyMatch(x->x.relatedCardId().id().equals(childCardId)));\n        ensure(\"a correct ChildAttached event is generated\", () -> getLastDomainEvent().equals(new CardEvents.ChildAttached(getBoardId(), getWorkflowId(), getCardId(), CardId.valueOf(childCardId), userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    @Override\n    public CardId getId() {\n        return getCardId();\n    }\n\n    @Override\n    public String getCategory() {\n        return CATEGORY;\n    }\n\n    private int getDomainEventSize() {\n        return getDomainEvents().size();\n    }\n\n    private CardEvents getLastDomainEvent() {\n        return getDomainEvents().get(getDomainEvents().size() - 1);\n    }\n\n    @Override\n    protected void ensureInvariant() {\n        invariant(\"is not marked as deleted\", () -> !isDeleted());\n        invariantNotNull(\"Board id\", getBoardId());\n        invariantNotNull(\"Workflow id\", getWorkflowId());\n        invariantNotNull(\"Lane id\", getLaneId());\n        invariantNotNull(\"Card id\", getCardId());\n        invariant(format(\"CATEGORY '%s'\", getCategory()), () -> getCategory().equals(CATEGORY));\n    }\n\n    private boolean _users_are_not_assigned(List<String> assigneeIds) {\n        for(String assigneeId: assigneeIds){\n            if(getAssignees().stream().anyMatch(x->x.userId().equals(assigneeId))){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean _users_are_assigned(List<String>\n        你的 trasient variables 有很多重複，其實完全沒有必要使用 transient variables，各個會用到的 methods 中使用 local variables 就可以了\n您提出了一個非常好的改進點。您是對的，使用大量 transient 變數是不必要的，而且可能會導致混淆。使用本地變數會使代碼更加清晰和維護性更高。\n\n讓我修改一下代碼，去除這些 transient 變數：\n\n```java\npublic class Card extends EsAggregateRoot<CardId, CardEvents> {\n\n    public final static String CATEGORY = \"Card\";\n    \n    // 聚合根的狀態屬性\n    private CardId cardId;\n    private BoardId boardId;\n    private WorkflowId workflowId;\n    private LaneId laneId;\n    private String description;\n    private String estimate;\n    private String note;\n    private Instant deadline;\n    private CardType type;\n    private String userId;\n    private boolean isDeleted;\n    private List<Blocker> blockers;\n    private List<Assignee> assignees;\n    private Set<TagId> tagIds;\n    private Set<RelatedCard> relatedCards;\n\n    // 空構造函數，供事件重播使用\n    protected Card() {\n        super();\n        this.blockers = new ArrayList<>();\n        this.assignees = new ArrayList<>();\n        this.tagIds = new HashSet<>();\n        this.relatedCards = new HashSet<>();\n        this.isDeleted = false;\n    }\n\n    // 主構造函數\n    public Card(BoardId boardId, WorkflowId workflowId, LaneId laneId, CardId cardId, String description,\n                String estimate, String note, Instant deadline, CardType type, int order, String userId, Set<RelatedCard> relatedCards) {\n        super();\n        requireNotNull(\"Board id\", boardId);\n        requireNotNull(\"Workflow id\", workflowId);\n        requireNotNull(\"Lane id\", laneId);\n        requireNotNull(\"Card id\", cardId);\n        requireNotNull(\"description\", description);\n        requireNotNull(\"card type\", type);\n        require(format(\"card expected order %d be non negative\", order), () -> order >= 0);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        requireNotNull(\"related cards\", relatedCards);\n\n        // 初始化屬性\n        this.blockers = new ArrayList<>();\n        this.assignees = new ArrayList<>();\n        this.tagIds = new HashSet<>();\n        \n        // 應用創建事件\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardCreated(boardId, workflowId, laneId, cardId, description, estimate, note, deadline, type, order, userId, relatedCards, eventId, occurredOn));\n\n        // 驗證後置條件\n        ensure(format(\"Card's card id is '%s'\", cardId.id()), () -> cardId.equals(getCardId()));\n        ensure(format(\"Card's board id is '%s'\", boardId.id()), () -> boardId.equals(getBoardId()));\n        ensure(format(\"Card's workflow id is '%s'\", workflowId.id()), () -> workflowId.equals(getWorkflowId()));\n        ensure(format(\"Card's lane id is '%s'\", laneId.id()), () -> laneId.equals(getLaneId()));\n        ensure(format(\"Card's description is '%s'\", description), () -> description.equals(getDescription()));\n        ensure(format(\"Card's estimate is '%s'\", estimate), () -> estimate.equals(getEstimate()));\n        ensure(format(\"Card's note is '%s'\", note), () -> note.equals(getNote()));\n        ensure(format(\"Card's deadline is '%s'\", deadline), () -> null == deadline ? null == getDeadline() : deadline.equals(getDeadline()));\n        ensure(format(\"Card's type is '%s'\", type.name()), () -> type.equals(getType()));\n        ensure(format(\"Card's user id is '%s'\", userId), () -> userId.equals(getUserId()));\n        ensure(format(\"Card's related cards is '%s'\", relatedCards), () -> relatedCards.equals(getRelatedCards()));\n        ensure(format(\"Card id '%s' equals aggregate id '%s'\", getCardId(), getId()), ()-> getCardId().equals(getId()));\n        ensureNotNull(\"blockers\", this.blockers);\n        ensure(\"Blockers size is 0\", () -> this.blockers.size() == 0);\n        ensure(\"Tag ids size is 0\", () -> getTagIds().size() == 0);\n        ensureNotNull(\"Assignees\", getAssignees());\n        ensure(\"Assignees size is 0\", () -> getAssignees().size() == 0);\n        ensure(\"a correct CardCreated event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardCreated(boardId, workflowId, laneId, cardId, description, estimate, note, deadline, type, order, userId, relatedCards, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n        ensure(\"Card events aggregate id equals to card id\", () -> getLastDomainEvent().aggregateId().equals(getCardId().id()));\n    }\n\n    // 使用事件列表構造聚合根\n    public Card(List<CardEvents> events) {\n        super(events);\n    }\n\n    // 實作 when 方法，處理各種事件\n    @Override\n    protected void when(CardEvents event) {\n        if (event instanceof CardEvents.CardCreated e) {\n            this.cardId = e.cardId();\n            this.boardId = e.boardId();\n            this.workflowId = e.workflowId();\n            this.laneId = e.laneId();\n            this.description = e.description();\n            this.estimate = e.estimate();\n            this.note = e.note();\n            this.deadline = e.deadline();\n            this.type = e.type();\n            this.userId = e.userId();\n            this.relatedCards = new HashSet<>(e.relatedCards());\n            this.blockers = new ArrayList<>();\n            this.assignees = new ArrayList<>();\n            this.tagIds = new HashSet<>();\n            this.isDeleted = false;\n        } else if (event instanceof CardEvents.CardDeleted) {\n            this.isDeleted = true;\n        } else if (event instanceof CardEvents.CardDescriptionChanged e) {\n            this.description = e.description();\n        } else if (event instanceof CardEvents.CardEstimateChanged e) {\n            this.estimate = e.estimate();\n        } else if (event instanceof CardEvents.CardNoteChanged e) {\n            this.note = e.note();\n        } else if (event instanceof CardEvents.CardTypeChanged e) {\n            this.type = e.type();\n        } else if (event instanceof CardEvents.CardDeadlineChanged e) {\n            this.deadline = e.deadline();\n        } else if (event instanceof CardEvents.CardMoved e) {\n            this.workflowId = e.workflowId();\n            this.laneId = e.newLaneId();\n        } else if (event instanceof CardEvents.CardBlocked e) {\n            Blocker blocker = new Blocker(\n                e.blockerId(),\n                e.blockerName(),\n                e.blockReason(),\n                e.occurredOn(),\n                null,\n                null,\n                BlockerStatus.Block\n            );\n            this.blockers.add(blocker);\n        } else if (event instanceof CardEvents.CardUnblocked e) {\n            this.blockers.stream()\n                .filter(b -> b.getId().equals(e.blockerId()) && b.getStatus().equals(BlockerStatus.Block))\n                .findFirst()\n                .ifPresent(blocker -> {\n                    blocker.setEndDate(e.occurredOn());\n                    blocker.setUnblockReason(e.reason());\n                    blocker.setStatus(BlockerStatus.Unblock);\n                });\n        } else if (event instanceof CardEvents.BlockerReasonChanged e) {\n            this.blockers.stream()\n                .filter(b -> b.getId().equals(e.blockerId()) && b.getStatus().equals(BlockerStatus.Block))\n                .findFirst()\n                .ifPresent(blocker -> blocker.setBlockReason(e.reason()));\n        } else if (event instanceof CardEvents.CardAssigned e) {\n            this.assignees.add(new Assignee(e.assigneeId(), this.cardId));\n        } else if (event instanceof CardEvents.CardUnassigned e) {\n            this.assignees.removeIf(a -> a.userId().equals(e.assigneeId()));\n        } else if (event instanceof CardEvents.TagAssigned e) {\n            this.tagIds.add(e.tagId());\n        } else if (event instanceof CardEvents.TagUnassigned e) {\n            this.tagIds.remove(e.tagId());\n        } else if (event instanceof CardEvents.ChildAttached e) {\n            this.relatedCards.add(new RelatedCard(e.childCardId(), RelationshipType.Child));\n        }\n    }\n    \n    // 業務行為方法\n    public void markAsDeleted(String userId) {\n        require(\"Card is not deleted\", () -> !isDeleted());\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardDeleted(this.boardId, this.workflowId, this.laneId, this.cardId, userId, eventId, occurredOn));\n\n        ensure(\"Card is marked as deleted\", () -> isDeleted());\n        ensure(\"a correct CardDeleted event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDeleted(getBoardId(), getWorkflowId(), getLaneId(), getCardId(), userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public boolean isDeleted() {\n        return ensureResult(\"result should be correct\", this.isDeleted, result -> result == this.isDeleted);\n    }\n\n    public void changeDescription(String newDescription, String userId) {\n        requireNotNull(\"new description\", newDescription);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if (reject(\"same description\", () -> newDescription.equals(getDescription()))) return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardDescriptionChanged(this.boardId, this.workflowId, this.cardId, newDescription, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's description is '%s'\", newDescription), ()-> getDescription().equals(newDescription));\n        ensure(\"a correct CardDescriptionChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDescriptionChanged(getBoardId(), getWorkflowId(), getCardId(), newDescription, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeEstimate(String newEstimate, String userId) {\n        requireNotNull(\"new estimate\", newEstimate);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same estimate\", () -> newEstimate.equals(getEstimate())))  return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardEstimateChanged(this.boardId, this.workflowId, this.cardId, newEstimate, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's estimate is '%s'\", newEstimate), ()-> getEstimate().equals(newEstimate));\n        ensure(\"a correct CardEstimateChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardEstimateChanged(getBoardId(), getWorkflowId(), getCardId(), newEstimate, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeNote(String newNote, String userId) {\n        requireNotNull(\"New note\", newNote);\n        requireNotEmpty(\"New note\", newNote);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardNoteChanged(this.boardId, this.workflowId, this.cardId, newNote, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's note is '%s'\", newNote), () -> newNote.equals(getNote()));\n        ensure(\"a correct CardNoteChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardNoteChanged(getBoardId(), getWorkflowId(), getCardId(), newNote, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeType(CardType newType, String userId) {\n        requireNotNull(\"New type\", newType);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same type\", () -> newType.equals(getType()))) return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardTypeChanged(this.boardId, this.workflowId, this.cardId, newType, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's type is '%s'\", newType.name()), () -> newType.equals(getType()));\n        ensure(\"a correct CardTypeChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardTypeChanged(getBoardId(), getWorkflowId(), getCardId(), newType, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeDeadline(Instant newDeadline, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same deadline\", () -> null == getDeadline() ? null == newDeadline : getDeadline().equals(newDeadline))) return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardDeadlineChanged(this.boardId, this.workflowId, this.cardId, newDeadline, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's deadline is '%s'\", newDeadline), ()-> null == newDeadline ? null == getDeadline() : getDeadline().equals(newDeadline));\n        ensure(\"a correct CardDeadlineChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDeadlineChanged(getBoardId(), getWorkflowId(), getCardId(), newDeadline, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public CardId getCardId() {\n        return ensureResult(\"result should be correct\", this.cardId, result -> result.equals(this.cardId));\n    }\n\n    public String getDescription() {\n        return ensureResult(\"result should be correct\", this.description, result -> result.equals(this.description));\n    }\n\n    public String getEstimate() {\n        return ensureResult(\"result should be correct\", this.estimate, result -> result.equals(this.estimate));\n    }\n\n    public String getNote() {\n        return ensureResult(\"result should be correct\", this.note, result -> result.equals(this.note));\n    }\n\n    public Instant getDeadline() {\n        return ensureResult(\"result should be correct\", this.deadline, result -> result.equals(this.deadline));\n    }\n\n    public CardType getType() {\n        return ensureResult(\"result should be correct\", this.type, result -> result.equals(this.type));\n    }\n\n    public void move(WorkflowId workflowId, LaneId newLaneId, String userId, int newOrder) {\n        requireNotNull(\"Workflow id\", workflowId);\n        requireNotNull(\"Lane id\", newLaneId);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        require(\"Order >= 0\", () -> newOrder >= 0);\n\n        LaneId oldLaneId = old(() -> getLaneId());\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardMoved(this.boardId, workflowId, this.cardId, oldLaneId, newLaneId, newOrder, userId, eventId, occurredOn));\n\n        ensure(format(\"Workflow id is '%s'\", workflowId), () -> getWorkflowId().equals(workflowId));\n        ensure(format(\"Lane id is '%s'\", newLaneId), () -> getLaneId().equals(newLaneId));\n        ensure(\"a correct CardMoved event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardMoved(getBoardId(), getWorkflowId(), getCardId(), oldLaneId, newLaneId, newOrder, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public BoardId getBoardId() {\n        return ensureResult(\"result is correct\", this.boardId, result -> result.equals(this.boardId));\n    }\n\n    public WorkflowId getWorkflowId() {\n        return ensureResult(\"result is correct\", this.workflowId, result -> result.equals(this.workflowId));\n    }\n\n    public LaneId getLaneId() {\n        return ensureResult(\"result is correct\", this.laneId, result -> result.equals(this.laneId));\n    }\n\n    public String getUserId() {\n        return ensureResult(\"result is correct\", this.userId, result -> result.equals(this.userId));\n    }\n\n    public void block(BlockerId blockerId, String blockerName, String blockReason, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        requireNotNull(\"blocker id\", blockerId);\n        requireNotNull(\"blocker name\", blockerName);\n        requireNotEmpty(\"blocker name\", blockerName);\n        requireNotNull(\"blocker reason\", blockReason);\n        require(\"Card has not been blocked\", () -> !isBlocked());\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardBlocked(this.boardId, this.workflowId, this.cardId, blockerId, blockerName, blockReason, userId, eventId, occurredOn));\n\n        ensure(\"Card is blocked\", () -> isBlocked());\n        ensure(format(\"Blocker id is '%s'\", blockerId), () -> getBlocker().get().getId().equals(blockerId));\n        ensure(format(\"Blocker name is '%s'\", blockerName), () -> getBlocker().get().getName().equals(blockerName));\n        ensure(format(\"Blocker reason is '%s'\", blockReason), () -> getBlocker().get().getBlockReason().equals(blockReason));\n        ensure(\"a correct CardBlocked event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardBlocked(getBoardId(), getWorkflowId(), getCardId(), blockerId, blockerName, blockReason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void unblock(String reason, String userId) {\n        requireNotNull(\"unblock reason\", reason);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        require(\"card has been blocked\", () -> isBlocked());\n\n        Blocker oldBlocker = old(() -> getBlocker().get());\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardUnblocked(this.boardId, this.workflowId, this.cardId, oldBlocker.getId(), reason, userId, eventId, occurredOn));\n\n        ensure(\"card is unblocked\", () -> !isBlocked());\n        ensure(\"unblocker is in blocker list\", () -> this.blockers.stream().anyMatch(x-> x.getId().equals(oldBlocker.getId())));\n        ensure(format(\"unblock reason is '%s'\", reason), () -> this.blockers.stream().anyMatch(x-> x.getId().equals(oldBlocker.getId()) && x.getUnblockReason().equals(reason)));\n        ensure(\"unblocked blocker's end date is correct\", () -> getUnblockers().get(getUnblockers().size()-1).getEndDate().equals(getLastDomainEvent().occurredOn()));\n        ensure(\"a correct CardUnblocked event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardUnblocked(getBoardId(), getWorkflowId(), getCardId(), oldBlocker.getId(), reason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeBlockerReason(String reason, String userId) {\n        requireNotNull(\"block reason\", reason);\n        requireNotNull(\"user id\", userId);\n        require(\"Card is blocked\", () -> isBlocked());\n\n        BlockerId blockerId = getBlocker().get().getId();\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.BlockerReasonChanged(this.boardId, this.workflowId, this.cardId, blockerId, reason, userId, eventId, occurredOn));\n\n        ensure(\"Card is blocked\", () -> isBlocked());\n        ensure(format(\"Block reason is '%s'\", reason), () -> getBlocker().get().getBlockReason().equals(reason));\n        ensure(\"a correct BlockerReasonChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.BlockerReasonChanged(getBoardId(), getWorkflowId(), getCardId(), getBlocker().get().getId(), reason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public Optional<Blocker> getBlocker() {\n        Optional<Blocker> result = this.blockers.stream()\n                .filter(b -> b.getStatus().equals(BlockerStatus.Block))\n                .findFirst();\n        return ensureResult(\"result is correct\", result,\n                r -> r.map(blocker -> blocker.isBlocked())\n                    .orElse(() -> this.blockers.stream().noneMatch(x->x.getStatus().equals(BlockerStatus.Block))));\n    }\n\n    public boolean isBlocked() {\n        boolean result = getBlocker().isPresent();\n        return ensureResult(\"result is correct\", result, r -> r == getBlocker().isPresent());\n    }\n\n    public List<Blocker> getUnblockers() {\n        List<Blocker> result = this.blockers.stream()\n                .filter(b -> b.getStatus().equals(BlockerStatus.Unblock))\n                .collect(Collectors.toUnmodifiableList());\n        return ensureImmutableCollection(result);\n    }\n\n    public void assignUsers(List<String> assigneeIds, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotNull(\"assignee ids\", assigneeIds);\n        require(\"users are not assigned\", () -> _users_are_not_assigned(assigneeIds));\n        require(\"list of user id to be assigned cannot be empty\", () -> !assigneeIds.isEmpty());\n\n        var oldDomainEventsSize = old(() -> getDomainEventSize());\n\n        for (String assigneeId : assigneeIds) {\n            UUID eventId = UUID.randomUUID();\n            Instant occurredOn = Instant.now();\n            apply(new CardEvents.CardAssigned(this.boardId, this.workflowId, this.cardId, assigneeId, userId, eventId, occurredOn));\n        }\n\n        ensure(\"users are assigned to assignee list\", () -> _users_are_assigned(assigneeIds));\n        ensure(format(\"size of domain event increased by %d\", assigneeIds.size()), () -> assigneeIds.size() == (getDomainEventSize() - oldDomainEventsSize));\n        ensure(\"all CardAssigned events are correctly generated\", () -> _check_card_assigned_events(assigneeIds, userId));\n    }\n\n    public void unassignUsers(List<String> unassigneeIds, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotNull(\"unassignee ids\", unassigneeIds);\n        require(\"users are assigned\", () -> _users_are_assigned(unassigneeIds));\n        require(\"list of user id to be assigned cannot be empty\", () -> !unassigneeIds.isEmpty());\n\n        var oldDomainEventsSize = old(() -> getDomainEventSize());\n\n        for (String unassigneeId : unassigneeIds) {\n            UUID eventId = UUID.randomUUID();\n            Instant occurredOn = Instant.now();\n            apply(new CardEvents.CardUnassigned(this.boardId, this.workflowId, this.cardId, unassigneeId, userId, eventId, occurredOn));\n        }\n\n        ensure(\"users are unassigned from assignee list\", () -> _users_are_not_assigned(unassigneeIds));\n        ensure(format(\"size of domain event increased by %d\", unassigneeIds.size()), () -> unassigneeIds.size() == (getDomainEventSize() - oldDomainEventsSize));\n        ensure(\"all CardUnassigned events are correctly generated\", () -> _check_card_unassigned_events(unassigneeIds, userId));\n    }\n\n    public List<Assignee> getAssignees() {\n        List<Assignee> result = Collections.unmodifiableList(this.assignees);\n        return ensureImmutableCollection(result);\n    }\n\n    public Optional<Assignee> getAssignee(String assigneeId) {\n        Optional<Assignee> result = this.assignees.stream()\n                .filter(a -> a.userId().equals(assigneeId))\n                .findFirst();\n        return ensureResult(\"result is correct\", result,\n                r -> r.map(assignee -> assignee.userId().equals(assigneeId))\n                     .orElse(this.assignees.stream().noneMatch(assignee -> assignee.userId().equals(assigneeId))));\n    }\n\n    public void assignTag(TagId tagId, String userId) {\n        requireNotNull(\"Tag id\", tagId);\n        requireNotNull(\"User id\", userId);\n        require(format(\"Tag is not assigned\", tagId), () -> !getTagIds().contains(tagId));\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.TagAssigned(this.boardId, this.workflowId, this.cardId, tagId, userId, eventId, occurredOn));\n\n        ensure(format(\"Tag '%s' is assigned to card '%s'\", tagId, getCardId()), () -> getTagIds().contains(tagId));\n        ensure(\"a correct TagAssigned event is generated\", () -> getLastDomainEvent().equals(new CardEvents.TagAssigned(getBoardId(), getWorkflowId(), getCardId(), tagId, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void unassignTag(TagId tagId, String userId) {\n        requireNotNull(\"Tag id\", tagId);\n        requireNotNull(\"User id\", userId);\n        require(format(\"Tag '%s' has been assigned to the card '%s'\", tagId, getCardId()), () -> getTagIds().contains(tagId));\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.TagUnassigned(this.boardId, this.workflowId, this.cardId, tagId, userId, eventId, occurredOn));\n\n        ensure(format(\"Tag '%s' is unassigned from card '%s'\", tagId, getCardId()), () -> !getTagIds().contains(tagId));\n        ensure(\"a correct TagUnassigned event is generated\", () -> getLastDomainEvent().equals(new CardEvents.TagUnassigned(getBoardId(), getWorkflowId(), getCardId(), tagId, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public Set<TagId> getTagIds() {\n        Set<TagId> result = Collections.unmodifiableSet(this.tagIds);\n        return ensureImmutableCollection(result);\n    }\n\n    public Set<RelatedCard> getRelatedCards() {\n        Set<RelatedCard> result = Collections.unmodifiableSet(this.relatedCards);\n        return ensureImmutableCollection(result);\n    }\n\n    public void attachChild(String childCardId, String userId) {\n        requireNotNull(\"ChildCard id\", childCardId);\n        requireNotNull(\"User id\", userId);\n\n        CardId childId = CardId.valueOf(childCardId);\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.ChildAttached(this.boardId, this.workflowId, this.cardId, childId, userId, eventId, occurredOn));\n\n        ensure(format(\"ChildCard id '%s' is attached to ParentCard id '%s'\", childCardId, getCardId()), () -> getRelatedCards().stream().anyMatch(x->x.relatedCardId().id().equals(childCardId)));\n        ensure(\"a correct ChildAttached event is generated\", () -> getLastDomainEvent().equals(new CardEvents.ChildAttached(getBoardId(), getWorkflowId(), getCardId(), CardId.valueOf(childCardId), userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    @Override\n    public CardId getId() {\n        return getCardId();\n    }\n\n    @Override\n    public String getCategory() {\n        return CATEGORY;\n    }\n\n    private int getDomainEventSize() {\n        return getDomainEvents().size();\n    }\n\n    private CardEvents getLastDomainEvent() {\n        return getDomainEvents().get(getDomainEvents().size() - 1);\n    }\n\n    @Override\n    protected void ensureInvariant() {\n        invariant(\"is not marked as deleted\", () -> !isDeleted());\n        invariantNotNull(\"Board id\", getBoardId());\n        invariantNotNull(\"Workflow id\", getWorkflowId());\n        invariantNotNull(\"Lane id\", getLaneId());\n        invariantNotNull(\"Card id\", getCardId());\n        invariant(format(\"CATEGORY '%s'\", getCategory()), () -> getCategory().equals(CATEGORY));\n    }\n\n    private boolean _users_are_not_assigned(List<String> assigneeIds) {\n        for(String assigneeId: assigneeIds){\n            if(getAssignees().stream().anyMatch(x->x.userId().equals(assigneeId))){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean _users_are_assigned(List<String> assigneeIds) {\n        for (String assigneeId : assigneeIds) {\n            var assignee = getAssignees().stream().filter(x -> x.userId().equals(assigneeId)).findFirst();\n            if (assignee.isEmpty()) {\n                return false;\n            }\n            if (null == assignee.get().cardId()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean _check_card_assigned_events(List<String> assigneeIds, String userId) {\n        try {\n            int i = getDomainEventSize() - assigneeIds.size();\n            for (String each : assigneeIds) {\n                if (!getDomainEvents().get(i).equals(new CardEvents.CardAssigned(\n                        getBoardId(),\n                        getWorkflowId(),\n                        getCardId(),\n                        each,\n                        userId,\n                        getDomainEvents().get(i).id(),\n                        getDomainEvents().get(i).occurredOn()))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private\n你程式怎麼沒寫完？\n很抱歉，程式確實沒有完成。以下是完整的修正後代碼：\n\n```java\npublic class Card extends EsAggregateRoot<CardId, CardEvents> {\n\n    public final static String CATEGORY = \"Card\";\n    \n    // 聚合根的狀態屬性\n    private CardId cardId;\n    private BoardId boardId;\n    private WorkflowId workflowId;\n    private LaneId laneId;\n    private String description;\n    private String estimate;\n    private String note;\n    private Instant deadline;\n    private CardType type;\n    private String userId;\n    private boolean isDeleted;\n    private List<Blocker> blockers;\n    private List<Assignee> assignees;\n    private Set<TagId> tagIds;\n    private Set<RelatedCard> relatedCards;\n\n    // 空構造函數，供事件重播使用\n    protected Card() {\n        super();\n        this.blockers = new ArrayList<>();\n        this.assignees = new ArrayList<>();\n        this.tagIds = new HashSet<>();\n        this.relatedCards = new HashSet<>();\n        this.isDeleted = false;\n    }\n\n    // 主構造函數\n    public Card(BoardId boardId, WorkflowId workflowId, LaneId laneId, CardId cardId, String description,\n                String estimate, String note, Instant deadline, CardType type, int order, String userId, Set<RelatedCard> relatedCards) {\n        super();\n        requireNotNull(\"Board id\", boardId);\n        requireNotNull(\"Workflow id\", workflowId);\n        requireNotNull(\"Lane id\", laneId);\n        requireNotNull(\"Card id\", cardId);\n        requireNotNull(\"description\", description);\n        requireNotNull(\"card type\", type);\n        require(format(\"card expected order %d be non negative\", order), () -> order >= 0);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        requireNotNull(\"related cards\", relatedCards);\n\n        // 初始化屬性\n        this.blockers = new ArrayList<>();\n        this.assignees = new ArrayList<>();\n        this.tagIds = new HashSet<>();\n        \n        // 應用創建事件\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardCreated(boardId, workflowId, laneId, cardId, description, estimate, note, deadline, type, order, userId, relatedCards, eventId, occurredOn));\n\n        // 驗證後置條件\n        ensure(format(\"Card's card id is '%s'\", cardId.id()), () -> cardId.equals(getCardId()));\n        ensure(format(\"Card's board id is '%s'\", boardId.id()), () -> boardId.equals(getBoardId()));\n        ensure(format(\"Card's workflow id is '%s'\", workflowId.id()), () -> workflowId.equals(getWorkflowId()));\n        ensure(format(\"Card's lane id is '%s'\", laneId.id()), () -> laneId.equals(getLaneId()));\n        ensure(format(\"Card's description is '%s'\", description), () -> description.equals(getDescription()));\n        ensure(format(\"Card's estimate is '%s'\", estimate), () -> estimate.equals(getEstimate()));\n        ensure(format(\"Card's note is '%s'\", note), () -> note.equals(getNote()));\n        ensure(format(\"Card's deadline is '%s'\", deadline), () -> null == deadline ? null == getDeadline() : deadline.equals(getDeadline()));\n        ensure(format(\"Card's type is '%s'\", type.name()), () -> type.equals(getType()));\n        ensure(format(\"Card's user id is '%s'\", userId), () -> userId.equals(getUserId()));\n        ensure(format(\"Card's related cards is '%s'\", relatedCards), () -> relatedCards.equals(getRelatedCards()));\n        ensure(format(\"Card id '%s' equals aggregate id '%s'\", getCardId(), getId()), ()-> getCardId().equals(getId()));\n        ensureNotNull(\"blockers\", this.blockers);\n        ensure(\"Blockers size is 0\", () -> this.blockers.size() == 0);\n        ensure(\"Tag ids size is 0\", () -> getTagIds().size() == 0);\n        ensureNotNull(\"Assignees\", getAssignees());\n        ensure(\"Assignees size is 0\", () -> getAssignees().size() == 0);\n        ensure(\"a correct CardCreated event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardCreated(boardId, workflowId, laneId, cardId, description, estimate, note, deadline, type, order, userId, relatedCards, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n        ensure(\"Card events aggregate id equals to card id\", () -> getLastDomainEvent().aggregateId().equals(getCardId().id()));\n    }\n\n    // 使用事件列表構造聚合根\n    public Card(List<CardEvents> events) {\n        super(events);\n    }\n\n    // 實作 when 方法，處理各種事件\n    @Override\n    protected void when(CardEvents event) {\n        if (event instanceof CardEvents.CardCreated e) {\n            this.cardId = e.cardId();\n            this.boardId = e.boardId();\n            this.workflowId = e.workflowId();\n            this.laneId = e.laneId();\n            this.description = e.description();\n            this.estimate = e.estimate();\n            this.note = e.note();\n            this.deadline = e.deadline();\n            this.type = e.type();\n            this.userId = e.userId();\n            this.relatedCards = new HashSet<>(e.relatedCards());\n            this.blockers = new ArrayList<>();\n            this.assignees = new ArrayList<>();\n            this.tagIds = new HashSet<>();\n            this.isDeleted = false;\n        } else if (event instanceof CardEvents.CardDeleted) {\n            this.isDeleted = true;\n        } else if (event instanceof CardEvents.CardDescriptionChanged e) {\n            this.description = e.description();\n        } else if (event instanceof CardEvents.CardEstimateChanged e) {\n            this.estimate = e.estimate();\n        } else if (event instanceof CardEvents.CardNoteChanged e) {\n            this.note = e.note();\n        } else if (event instanceof CardEvents.CardTypeChanged e) {\n            this.type = e.type();\n        } else if (event instanceof CardEvents.CardDeadlineChanged e) {\n            this.deadline = e.deadline();\n        } else if (event instanceof CardEvents.CardMoved e) {\n            this.workflowId = e.workflowId();\n            this.laneId = e.newLaneId();\n        } else if (event instanceof CardEvents.CardBlocked e) {\n            Blocker blocker = new Blocker(\n                e.blockerId(),\n                e.blockerName(),\n                e.blockReason(),\n                e.occurredOn(),\n                null,\n                null,\n                BlockerStatus.Block\n            );\n            this.blockers.add(blocker);\n        } else if (event instanceof CardEvents.CardUnblocked e) {\n            this.blockers.stream()\n                .filter(b -> b.getId().equals(e.blockerId()) && b.getStatus().equals(BlockerStatus.Block))\n                .findFirst()\n                .ifPresent(blocker -> {\n                    blocker.setEndDate(e.occurredOn());\n                    blocker.setUnblockReason(e.reason());\n                    blocker.setStatus(BlockerStatus.Unblock);\n                });\n        } else if (event instanceof CardEvents.BlockerReasonChanged e) {\n            this.blockers.stream()\n                .filter(b -> b.getId().equals(e.blockerId()) && b.getStatus().equals(BlockerStatus.Block))\n                .findFirst()\n                .ifPresent(blocker -> blocker.setBlockReason(e.reason()));\n        } else if (event instanceof CardEvents.CardAssigned e) {\n            this.assignees.add(new Assignee(e.assigneeId(), this.cardId));\n        } else if (event instanceof CardEvents.CardUnassigned e) {\n            this.assignees.removeIf(a -> a.userId().equals(e.assigneeId()));\n        } else if (event instanceof CardEvents.TagAssigned e) {\n            this.tagIds.add(e.tagId());\n        } else if (event instanceof CardEvents.TagUnassigned e) {\n            this.tagIds.remove(e.tagId());\n        } else if (event instanceof CardEvents.ChildAttached e) {\n            this.relatedCards.add(new RelatedCard(e.childCardId(), RelationshipType.Child));\n        }\n    }\n    \n    // 業務行為方法\n    public void markAsDeleted(String userId) {\n        require(\"Card is not deleted\", () -> !isDeleted());\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardDeleted(this.boardId, this.workflowId, this.laneId, this.cardId, userId, eventId, occurredOn));\n\n        ensure(\"Card is marked as deleted\", () -> isDeleted());\n        ensure(\"a correct CardDeleted event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDeleted(getBoardId(), getWorkflowId(), getLaneId(), getCardId(), userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public boolean isDeleted() {\n        return ensureResult(\"result should be correct\", this.isDeleted, result -> result == this.isDeleted);\n    }\n\n    public void changeDescription(String newDescription, String userId) {\n        requireNotNull(\"new description\", newDescription);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if (reject(\"same description\", () -> newDescription.equals(getDescription()))) return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardDescriptionChanged(this.boardId, this.workflowId, this.cardId, newDescription, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's description is '%s'\", newDescription), ()-> getDescription().equals(newDescription));\n        ensure(\"a correct CardDescriptionChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDescriptionChanged(getBoardId(), getWorkflowId(), getCardId(), newDescription, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeEstimate(String newEstimate, String userId) {\n        requireNotNull(\"new estimate\", newEstimate);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same estimate\", () -> newEstimate.equals(getEstimate())))  return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardEstimateChanged(this.boardId, this.workflowId, this.cardId, newEstimate, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's estimate is '%s'\", newEstimate), ()-> getEstimate().equals(newEstimate));\n        ensure(\"a correct CardEstimateChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardEstimateChanged(getBoardId(), getWorkflowId(), getCardId(), newEstimate, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeNote(String newNote, String userId) {\n        requireNotNull(\"New note\", newNote);\n        requireNotEmpty(\"New note\", newNote);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardNoteChanged(this.boardId, this.workflowId, this.cardId, newNote, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's note is '%s'\", newNote), () -> newNote.equals(getNote()));\n        ensure(\"a correct CardNoteChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardNoteChanged(getBoardId(), getWorkflowId(), getCardId(), newNote, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeType(CardType newType, String userId) {\n        requireNotNull(\"New type\", newType);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same type\", () -> newType.equals(getType()))) return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardTypeChanged(this.boardId, this.workflowId, this.cardId, newType, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's type is '%s'\", newType.name()), () -> newType.equals(getType()));\n        ensure(\"a correct CardTypeChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardTypeChanged(getBoardId(), getWorkflowId(), getCardId(), newType, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeDeadline(Instant newDeadline, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n\n        if(reject(\"same deadline\", () -> null == getDeadline() ? null == newDeadline : getDeadline().equals(newDeadline))) return;\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardDeadlineChanged(this.boardId, this.workflowId, this.cardId, newDeadline, userId, eventId, occurredOn));\n\n        ensure(format(\"Card's deadline is '%s'\", newDeadline), ()-> null == newDeadline ? null == getDeadline() : getDeadline().equals(newDeadline));\n        ensure(\"a correct CardDeadlineChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardDeadlineChanged(getBoardId(), getWorkflowId(), getCardId(), newDeadline, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public CardId getCardId() {\n        return ensureResult(\"result should be correct\", this.cardId, result -> result.equals(this.cardId));\n    }\n\n    public String getDescription() {\n        return ensureResult(\"result should be correct\", this.description, result -> result.equals(this.description));\n    }\n\n    public String getEstimate() {\n        return ensureResult(\"result should be correct\", this.estimate, result -> result.equals(this.estimate));\n    }\n\n    public String getNote() {\n        return ensureResult(\"result should be correct\", this.note, result -> result.equals(this.note));\n    }\n\n    public Instant getDeadline() {\n        return ensureResult(\"result should be correct\", this.deadline, result -> result.equals(this.deadline));\n    }\n\n    public CardType getType() {\n        return ensureResult(\"result should be correct\", this.type, result -> result.equals(this.type));\n    }\n\n    public void move(WorkflowId workflowId, LaneId newLaneId, String userId, int newOrder) {\n        requireNotNull(\"Workflow id\", workflowId);\n        requireNotNull(\"Lane id\", newLaneId);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        require(\"Order >= 0\", () -> newOrder >= 0);\n\n        LaneId oldLaneId = old(() -> getLaneId());\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardMoved(this.boardId, workflowId, this.cardId, oldLaneId, newLaneId, newOrder, userId, eventId, occurredOn));\n\n        ensure(format(\"Workflow id is '%s'\", workflowId), () -> getWorkflowId().equals(workflowId));\n        ensure(format(\"Lane id is '%s'\", newLaneId), () -> getLaneId().equals(newLaneId));\n        ensure(\"a correct CardMoved event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardMoved(getBoardId(), getWorkflowId(), getCardId(), oldLaneId, newLaneId, newOrder, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public BoardId getBoardId() {\n        return ensureResult(\"result is correct\", this.boardId, result -> result.equals(this.boardId));\n    }\n\n    public WorkflowId getWorkflowId() {\n        return ensureResult(\"result is correct\", this.workflowId, result -> result.equals(this.workflowId));\n    }\n\n    public LaneId getLaneId() {\n        return ensureResult(\"result is correct\", this.laneId, result -> result.equals(this.laneId));\n    }\n\n    public String getUserId() {\n        return ensureResult(\"result is correct\", this.userId, result -> result.equals(this.userId));\n    }\n\n    public void block(BlockerId blockerId, String blockerName, String blockReason, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        requireNotNull(\"blocker id\", blockerId);\n        requireNotNull(\"blocker name\", blockerName);\n        requireNotEmpty(\"blocker name\", blockerName);\n        requireNotNull(\"blocker reason\", blockReason);\n        require(\"Card has not been blocked\", () -> !isBlocked());\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardBlocked(this.boardId, this.workflowId, this.cardId, blockerId, blockerName, blockReason, userId, eventId, occurredOn));\n\n        ensure(\"Card is blocked\", () -> isBlocked());\n        ensure(format(\"Blocker id is '%s'\", blockerId), () -> getBlocker().get().getId().equals(blockerId));\n        ensure(format(\"Blocker name is '%s'\", blockerName), () -> getBlocker().get().getName().equals(blockerName));\n        ensure(format(\"Blocker reason is '%s'\", blockReason), () -> getBlocker().get().getBlockReason().equals(blockReason));\n        ensure(\"a correct CardBlocked event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardBlocked(getBoardId(), getWorkflowId(), getCardId(), blockerId, blockerName, blockReason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void unblock(String reason, String userId) {\n        requireNotNull(\"unblock reason\", reason);\n        requireNotNull(\"user id\", userId);\n        requireNotEmpty(\"user id\", userId);\n        require(\"card has been blocked\", () -> isBlocked());\n\n        Blocker oldBlocker = old(() -> getBlocker().get());\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.CardUnblocked(this.boardId, this.workflowId, this.cardId, oldBlocker.getId(), reason, userId, eventId, occurredOn));\n\n        ensure(\"card is unblocked\", () -> !isBlocked());\n        ensure(\"unblocker is in blocker list\", () -> this.blockers.stream().anyMatch(x-> x.getId().equals(oldBlocker.getId())));\n        ensure(format(\"unblock reason is '%s'\", reason), () -> this.blockers.stream().anyMatch(x-> x.getId().equals(oldBlocker.getId()) && x.getUnblockReason().equals(reason)));\n        ensure(\"unblocked blocker's end date is correct\", () -> getUnblockers().get(getUnblockers().size()-1).getEndDate().equals(getLastDomainEvent().occurredOn()));\n        ensure(\"a correct CardUnblocked event is generated\", () -> getLastDomainEvent().equals(new CardEvents.CardUnblocked(getBoardId(), getWorkflowId(), getCardId(), oldBlocker.getId(), reason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void changeBlockerReason(String reason, String userId) {\n        requireNotNull(\"block reason\", reason);\n        requireNotNull(\"user id\", userId);\n        require(\"Card is blocked\", () -> isBlocked());\n\n        BlockerId blockerId = getBlocker().get().getId();\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.BlockerReasonChanged(this.boardId, this.workflowId, this.cardId, blockerId, reason, userId, eventId, occurredOn));\n\n        ensure(\"Card is blocked\", () -> isBlocked());\n        ensure(format(\"Block reason is '%s'\", reason), () -> getBlocker().get().getBlockReason().equals(reason));\n        ensure(\"a correct BlockerReasonChanged event is generated\", () -> getLastDomainEvent().equals(new CardEvents.BlockerReasonChanged(getBoardId(), getWorkflowId(), getCardId(), getBlocker().get().getId(), reason, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public Optional<Blocker> getBlocker() {\n        Optional<Blocker> result = this.blockers.stream()\n                .filter(b -> b.getStatus().equals(BlockerStatus.Block))\n                .findFirst();\n        return ensureResult(\"result is correct\", result,\n                r -> r.map(blocker -> blocker.isBlocked())\n                    .orElse(() -> this.blockers.stream().noneMatch(x->x.getStatus().equals(BlockerStatus.Block))));\n    }\n\n    public boolean isBlocked() {\n        boolean result = getBlocker().isPresent();\n        return ensureResult(\"result is correct\", result, r -> r == getBlocker().isPresent());\n    }\n\n    public List<Blocker> getUnblockers() {\n        List<Blocker> result = this.blockers.stream()\n                .filter(b -> b.getStatus().equals(BlockerStatus.Unblock))\n                .collect(Collectors.toUnmodifiableList());\n        return ensureImmutableCollection(result);\n    }\n\n    public void assignUsers(List<String> assigneeIds, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotNull(\"assignee ids\", assigneeIds);\n        require(\"users are not assigned\", () -> _users_are_not_assigned(assigneeIds));\n        require(\"list of user id to be assigned cannot be empty\", () -> !assigneeIds.isEmpty());\n\n        var oldDomainEventsSize = old(() -> getDomainEventSize());\n\n        for (String assigneeId : assigneeIds) {\n            UUID eventId = UUID.randomUUID();\n            Instant occurredOn = Instant.now();\n            apply(new CardEvents.CardAssigned(this.boardId, this.workflowId, this.cardId, assigneeId, userId, eventId, occurredOn));\n        }\n\n        ensure(\"users are assigned to assignee list\", () -> _users_are_assigned(assigneeIds));\n        ensure(format(\"size of domain event increased by %d\", assigneeIds.size()), () -> assigneeIds.size() == (getDomainEventSize() - oldDomainEventsSize));\n        ensure(\"all CardAssigned events are correctly generated\", () -> _check_card_assigned_events(assigneeIds, userId));\n    }\n\n    public void unassignUsers(List<String> unassigneeIds, String userId) {\n        requireNotNull(\"user id\", userId);\n        requireNotNull(\"unassignee ids\", unassigneeIds);\n        require(\"users are assigned\", () -> _users_are_assigned(unassigneeIds));\n        require(\"list of user id to be assigned cannot be empty\", () -> !unassigneeIds.isEmpty());\n\n        var oldDomainEventsSize = old(() -> getDomainEventSize());\n\n        for (String unassigneeId : unassigneeIds) {\n            UUID eventId = UUID.randomUUID();\n            Instant occurredOn = Instant.now();\n            apply(new CardEvents.CardUnassigned(this.boardId, this.workflowId, this.cardId, unassigneeId, userId, eventId, occurredOn));\n        }\n\n        ensure(\"users are unassigned from assignee list\", () -> _users_are_not_assigned(unassigneeIds));\n        ensure(format(\"size of domain event increased by %d\", unassigneeIds.size()), () -> unassigneeIds.size() == (getDomainEventSize() - oldDomainEventsSize));\n        ensure(\"all CardUnassigned events are correctly generated\", () -> _check_card_unassigned_events(unassigneeIds, userId));\n    }\n\n    public List<Assignee> getAssignees() {\n        List<Assignee> result = Collections.unmodifiableList(this.assignees);\n        return ensureImmutableCollection(result);\n    }\n\n    public Optional<Assignee> getAssignee(String assigneeId) {\n        Optional<Assignee> result = this.assignees.stream()\n                .filter(a -> a.userId().equals(assigneeId))\n                .findFirst();\n        return ensureResult(\"result is correct\", result,\n                r -> r.map(assignee -> assignee.userId().equals(assigneeId))\n                     .orElse(this.assignees.stream().noneMatch(assignee -> assignee.userId().equals(assigneeId))));\n    }\n\n    public void assignTag(TagId tagId, String userId) {\n        requireNotNull(\"Tag id\", tagId);\n        requireNotNull(\"User id\", userId);\n        require(format(\"Tag is not assigned\", tagId), () -> !getTagIds().contains(tagId));\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.TagAssigned(this.boardId, this.workflowId, this.cardId, tagId, userId, eventId, occurredOn));\n\n        ensure(format(\"Tag '%s' is assigned to card '%s'\", tagId, getCardId()), () -> getTagIds().contains(tagId));\n        ensure(\"a correct TagAssigned event is generated\", () -> getLastDomainEvent().equals(new CardEvents.TagAssigned(getBoardId(), getWorkflowId(), getCardId(), tagId, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public void unassignTag(TagId tagId, String userId) {\n        requireNotNull(\"Tag id\", tagId);\n        requireNotNull(\"User id\", userId);\n        require(format(\"Tag '%s' has been assigned to the card '%s'\", tagId, getCardId()), () -> getTagIds().contains(tagId));\n\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.TagUnassigned(this.boardId, this.workflowId, this.cardId, tagId, userId, eventId, occurredOn));\n\n        ensure(format(\"Tag '%s' is unassigned from card '%s'\", tagId, getCardId()), () -> !getTagIds().contains(tagId));\n        ensure(\"a correct TagUnassigned event is generated\", () -> getLastDomainEvent().equals(new CardEvents.TagUnassigned(getBoardId(), getWorkflowId(), getCardId(), tagId, userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    public Set<TagId> getTagIds() {\n        Set<TagId> result = Collections.unmodifiableSet(this.tagIds);\n        return ensureImmutableCollection(result);\n    }\n\n    public Set<RelatedCard> getRelatedCards() {\n        Set<RelatedCard> result = Collections.unmodifiableSet(this.relatedCards);\n        return ensureImmutableCollection(result);\n    }\n\n    public void attachChild(String childCardId, String userId) {\n        requireNotNull(\"ChildCard id\", childCardId);\n        requireNotNull(\"User id\", userId);\n\n        CardId childId = CardId.valueOf(childCardId);\n        UUID eventId = UUID.randomUUID();\n        Instant occurredOn = Instant.now();\n        apply(new CardEvents.ChildAttached(this.boardId, this.workflowId, this.cardId, childId, userId, eventId, occurredOn));\n\n        ensure(format(\"ChildCard id '%s' is attached to ParentCard id '%s'\", childCardId, getCardId()), () -> getRelatedCards().stream().anyMatch(x->x.relatedCardId().id().equals(childCardId)));\n        ensure(\"a correct ChildAttached event is generated\", () -> getLastDomainEvent().equals(new CardEvents.ChildAttached(getBoardId(), getWorkflowId(), getCardId(), CardId.valueOf(childCardId), userId, getLastDomainEvent().id(), getLastDomainEvent().occurredOn())));\n    }\n\n    @Override\n    public CardId getId() {\n        return getCardId();\n    }\n\n    @Override\n    public String getCategory() {\n        return CATEGORY;\n    }\n\n    private int getDomainEventSize() {\n        return getDomainEvents().size();\n    }\n\n    private CardEvents getLastDomainEvent() {\n        return getDomainEvents().get(getDomainEvents().size() - 1);\n    }\n\n    @Override\n    protected void ensureInvariant() {\n        invariant(\"is not marked as deleted\", () -> !isDeleted());\n        invariantNotNull(\"Board id\", getBoardId());\n        invariantNotNull(\"Workflow id\", getWorkflowId());\n        invariantNotNull(\"Lane id\", getLaneId());\n        invariantNotNull(\"Card id\", getCardId());\n        invariant(format(\"CATEGORY '%s'\", getCategory()), () -> getCategory().equals(CATEGORY));\n    }\n\n    private boolean _users_are_not_assigned(List<String> assigneeIds) {\n        for(String assigneeId: assigneeIds){\n            if(getAssignees().stream().anyMatch(x->x.userId().equals(assigneeId))){\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean _users_are_assigned(List<String> assigneeIds) {\n        for (String assigneeId : assigneeIds) {\n            var assignee = getAssignees().stream().filter(x -> x.userId().equals(assigneeId)).findFirst();\n            if (assignee.isEmpty()) {\n                return false;\n            }\n            if (null == assignee.get().cardId()) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    private boolean _check_card_assigned_events(List<String> assigneeIds, String userId) {\n        try {\n            int i = getDomainEventSize() - assigneeIds.size();\n            for (String each : assigneeIds) {\n                if (!getDomainEvents().get(i).equals(new CardEvents.CardAssigned(\n                        getBoardId(),\n                        getWorkflowId(),\n                        getCardId(),\n                        each,\n                        userId,\n                        getDomainEvents().get(i).id(),\n                        getDomainEvents().get(i).occurredOn()))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    private boolean _check_card_unassigned_events(List<String> unassigneeIds, String userId) {\n        try {\n            int i = getDomainEventSize() - unassigneeIds.size();\n            for (String each : unassigneeIds) {\n                if (!getDomainEvents().get(i).equals(new CardEvents.CardUnassigned(\n                        getBoardId(),\n                        getWorkflowId(),\n                        getCardId(),\n                        each,\n                        userId,\n                        getDomainEvents().get(i).id(),\n                        getDomainEvents().get(i).occurredOn()))) {\n                    return false;\n                }\n                i++;\n            }\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n}\n```\n\n這樣整個 Card 類的實作就完成了。這個方法檢查是否所有的 CardUnassigned 事件都被正確生成，這是合約檢查的一部分。它會遍歷所有卡片解除分配的使用者 ID，並確保對應的事件正確地存在於領域事件列表中。\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5583}}},{"id":{"replica_id":0,"value":34},"start":86,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5584}}},{"id":{"replica_id":0,"value":39},"start":90,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5585}}},{"id":{"replica_id":0,"value":46},"start":2374,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5586}}},{"id":{"replica_id":0,"value":69},"start":2378,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5587}}},{"id":{"replica_id":0,"value":70},"start":4205,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5588}}},{"id":{"replica_id":0,"value":121},"start":4245,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5589}}},{"id":{"replica_id":0,"value":153},"start":4249,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5590}}},{"id":{"replica_id":0,"value":136},"start":4784,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5591}}},{"id":{"replica_id":0,"value":190},"start":4788,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5592}}},{"id":{"replica_id":0,"value":191},"start":6637,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5593}}},{"id":{"replica_id":0,"value":267},"start":6795,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5594}}},{"id":{"replica_id":0,"value":322},"start":6799,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5595}}},{"id":{"replica_id":0,"value":295},"start":25827,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5596}}},{"id":{"replica_id":0,"value":365},"start":25831,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5597}}},{"id":{"replica_id":0,"value":366},"start":29087,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5598}}},{"id":{"replica_id":0,"value":1016},"start":49627,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5599}}},{"id":{"replica_id":0,"value":1017},"start":78533,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5600}}},{"id":{"replica_id":0,"value":2678},"start":78666,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5601}}},{"id":{"replica_id":0,"value":2679},"start":107279,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5602}}},{"id":{"replica_id":0,"value":3421},"start":107450,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5603}}},{"id":{"replica_id":0,"value":3422},"start":136090,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5604}}},{"id":{"replica_id":0,"value":3908},"start":136118,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":5605}}},{"id":{"replica_id":0,"value":4951},"start":165637,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":5606}}}],"summary":"Event Sourced Aggregate Root Implementation","slash_command_output_sections":[{"range":{"start":0,"end":1},"icon":"Library","label":"Default","metadata":null}]}