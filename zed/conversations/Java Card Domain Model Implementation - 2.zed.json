{"id":"83269551-8b0a-4c9b-b538-be897faaf71a","zed":"context","version":"0.4.0","text":"你是一位使用Java jdk21 要使用Maven 專案，套用DDD與Clean Architecture，採用BDD來開發系統。\n請根據所提供的 Gherkin 格式需求的描述，將領域模型物件產生在 src/main/java 目錄的 tw.teddysoft.ai.bdd.cards.entity package。\n```\nFeature: Create Shadow Card\n\nScenario: create shadow card\nGiven a board Scrum_Board as following:\n|    Workflow   |    RootStage    |    Card      |\n|    Backlog    |    Refined      |    Card1     |\n|    Sprint     |    Selected     |              |\nWhen a user creates a shadow card of Card1 in the selected stage\nThen success\nAnd the shadow card should refer to the card1\nAnd a CardCreated event for the shadow card should be published\n\n\n\n\n\n\nFeature: Attach Child\n\nScenario: attach one child to card\nGiven a parent card\nAnd a child card\nWhen I attach child card to parent card\nThen success\nAnd the parent card should have one related card\nAnd the related card is child card\nAnd a child attached event should be published\n\n\n\n\n\n\nFeature: Unblock Card\n\nScenario: unblock a card\nGiven a card created at 2023-01-01T00:00:00Z\nAnd I block the card at 2023-01-01T01:00:00Z\nWhen I unblock the card at 2023-01-01T02:00:00Z\nThen success\nAnd the the card should not be blocked\nAnd the card should have an unblocker\nAnd the unblocker should be persisted\nAnd a card unblocked event should be published\n\n\n\n\n\n\nFeature: Change Blocker Reason\n\nScenario: change a blocker reason\nGiven a new card which is blocked at 2020-08-13T15:22:00.00Z\nWhen I change the reason of blocked card\nThen success\nAnd the new reason of blocked card should be persisted\nAnd a blocker reason changed event should be published\n\n\n\n\n\n\nFeature: Block cards\n\nScenario: block a card\nGiven a new card which is not blocked\nWhen a user blocks the card\nThen success\nAnd a CardBlocked event is published\n\nScenario: block a card after unblocking once\nGiven a new card which is not blocked\nAnd block the card\nAnd unblock the card\nWhen a user blocks the card\nThen success\nAnd card in repository is blocked correctly\nAnd a CardBlocked event is published\n\n\n\n\n\n\nFeature: Unassign tag\n\nScenario: unassign a tag from a card\nGiven a card with a tag\nWhen I unassign the tag from the card\nThen success\nAnd The card should have no tag\nAnd a tag assigned event should be published\n\n\n\n\n\n\nFeature: Unassign card\n\nScenario: unassign an assignee from a card\nGiven a card with two assignees as following:\n |    assignee         |\n |    Assignee1Id      |\n |    Assignee2Id      |\nWhen I unassign Assignee1 from the card\nThen success\nAnd the card should have one assignee, Assignee2\nAnd a card unassigned event should be published\n\n\n\n\n\n\nFeature: Move Card\n\nScenario: moving a card that violates optimistic locking should fail\nGiven two stages, To Do and Doing\nAnd a card created on To Do\nWhen I move the card from To Do to Doing with a different version number from DB\nThen failure\nAnd the card should still stay on To Do\nAnd no card moved event should be published\n\nScenario: moving the first card to the second position while the second card is being moved to a different lane is allowed\nGiven card1 and card2 are in the Analysis stage\nAnd Teddy moves the card1 below the card2\nAnd Patrick moves the card2 to the Development stage at the same time\nWhen Patrick's request is processed before Teddy's\nThen card2 should be moved to the Development stage\nAnd card1 should be stayed at the Analysis stage\n\nScenario: moving a card from todo stage to doing stage should succeed\nGiven two stages, To Do and Doing\nAnd a card created on To Do\nAnd another card created on Doing\nWhen I move the card from To Do to Doing\nThen success\nAnd the card should exist on Doing\nAnd a card moved event should be published\n\nScenario: moving a card to a different workflow should be allowed\nGiven two stages, To Do and Doing\nAnd a card created on To Do\nAnd another card created on Doing\nWhen I move the card from workflow1 to workflow2\nThen success\nAnd the card should be on Workflow 2\nAnd the card should exist on Doing\n\n\n\n\n\n\nFeature: Delete Card\n\nScenario: delete a card\nGiven a card\nWhen I delete the card\nThen success\nAnd the card should not exist\nAnd a card deleted event should be published\n\n\n\n\n\n\nFeature: Change Card Type\n\nScenario Outline: change a card type\n\nGiven a card with card type <oldType>\nWhen I change the card type to <newType>\nThen success\nAnd the card type should be changed to the assigned type <newType>\nAnd a card type changed event should be published\n\nExamples: \n|\toldType\t|\tnewType\t|\n| Expedite \t| Standard \t|\n| Standard \t| Expedite \t|\n\nScenario: change a card type with same type will not change generate event\nGiven a card with card type Standard\nWhen I change the card type with the same type\nThen success\nAnd the card type remains to be Standard\nAnd no card type changed event is published\n\n\n\n\n\n\nFeature: Change Card Note\n\nScenario: change a card note\nGiven a card\nWhen I change the card note should be newNote\nThen success\nAnd the card note should be changed to the assigned note\nAnd a card note changed event should be published\n\n\n\n\n\n\nFeature: Estimate A Card\n\nScenario: estimate a card with days\nGiven a card\nWhen I estimate the card should be finished within 13D\nThen success\nAnd the card estimation should be changed to the assigned estimation\nAnd a card estimate changed event should be published\n\nScenario: change the estimate a card with same estimate days will not generate\nGiven a card\nWhen I estimate the card should be finished within 13D\nThen success\nAnd the card estimation should be changed to the assigned estimation\nAnd no card estimate changed event is published\n\n\n\n\n\n\nFeature: Change Card Description\n\nScenario: change a card description\nGiven a card\nWhen I change the card description to EditedDescription\nThen success\nAnd the card description should be changed to the assigned description\nAnd a card description changed event should be published\n\nScenario: change a card description with same description will not throw event\nGiven a card\nWhen I change the card description with the same description\nThen success\nAnd the card description should be changed to the assigned description\nAnd no card description changed event is published\n\n\n\n\n\n\nFeature: Change Card Deadline\n\nScenario: change deadline of a card with no deadline\nGiven a card\nWhen I change the card deadline to 2020-03-02T00\nThen success\nAnd the card deadline should be changed to the assigned date\nAnd a card deadline changed event should be published\n\nScenario: change a card deadline\nGiven a card\nWhen I change the card deadline to 2020-03-02T00\nThen success\nAnd the card deadline should be changed to the assigned date\nAnd a card deadline changed event should be published\n\nScenario: change a card deadline with same deadline will not generate event\nGiven a card\nWhen I change the card deadline with the same deadline\nThen success\nAnd the card deadline remains to be to the same date\nAnd a card deadline changed event will not be published\n\nScenario: change deadline of a card with no deadline to null will not generate event\nGiven a card\nWhen I change the card deadline with the same deadline\nThen success\nAnd the card deadline remains to be null\nAnd a card deadline changed event will not be published\n\n\n\n\n\n\nFeature: Assign Tag\n\nScenario: assign a tag to a card\nGiven a card\nAnd a tag as following:\n|    tag         |\n|    tagId       |\nWhen I assign the tag to the card\nThen success\nAnd The card should have the tag\nAnd a tag assigned event should be published\n\n\n\n\n\n\nFeature: Assign Card\n\n\nRule: Behavior: Normal\nScenario: assigning a card to two board members should succeed\nGiven a card\nAnd two assignees as following:\n|    assignee         |\n|    Assignee1Id      |\n|    Assignee2Id      |\nWhen I assign the card to the two assignees\nThen success\nAnd the card should have the two assignees\nAnd two card assigned events should be published\n\n\nRule: Behavior: Abnormal\nScenario: assigning assignees contain a duplicated assignee should be rejected\nGiven a card assigned to an assignee\nWhen the card is assigned to assignees that contain the same assignee\nThen failure\nAnd the card should remain one assignee\nAnd the CardAssigned event should not be generated\n\nScenario: assigning a duplicated assignee should be rejected\nGiven a card assigned to an assignee\nWhen the card is assigned to the same assignee again\nThen failure\nAnd the card should remain one assignee\nAnd the CardAssigned event should not be generated\n\n\nRule: Structure\nScenario: card should exist\nGiven a non-existing card\nWhen the card is assigned to a assignee\nThen failure\nAnd the CardAssigned event should not be generated\n\n\n\n\n\n\nFeature: Create Card\n\nScenario: create a card in a root stage with order 1\nGiven a board with a workflow and a root stage\nAnd a card is created on the root stage\nWhen I crate second card on the root stage\nThen success\nAnd the card should be persisted\nAnd a card created event should be published\n\nScenario: create a card in a root stage\nGiven a board with a workflow and a root stage\nWhen I crate a card on the root stage\nThen success\nAnd the card should be persisted\nAnd a card created event should be published\n```\n\n領域模型的描述如下：\nAggregate Root: Card\nValue Object: Card Id, Board Id, Workflow Id, Lane Id, Tag Id\nString: User Id\nEnum: Card Type\n\nCard aggregate 使用event sourced aggregate 的設計風格，他繼承自 ezddd-core 的tw.teddysoft.ezddd.entity.EsAggregateRoot，並遵循 EsAggregateRoot的設計。\nEsAggregateRoot 程式碼如下：\n```\n\npublic abstract class EsAggregateRoot<ID, E extends DomainEvent> extends AggregateRoot<ID, E> {\n\n//region :Constructors\n    protected EsAggregateRoot() {\n        super();\n    }\n\n    public EsAggregateRoot(List<E> events) {\n        this();\n        requireNotNull(\"Domain events\", events);\n\n        replayEvents(events);\n        clearDomainEvents();\n\n        ensure(\"Domain event size is 0\", () -> getDomainEvents().size() == 0);\n        ensure(\"Aggregate id cannot be null\", () -> null != getId());\n    }\n\n    protected void replayEvents(List<E> events) {\n        events.forEach(this::apply);\n    }\n    //endregion\n\n    //region :Behaviors for the DomainEventSource\n    // template method\n    @Override\n    public final void apply(E event) {\n        if (!(event instanceof DomainEvent.ConstructionEvent))\n            ensureInvariant();\n        try {\n            when(event);\n        } catch (RuntimeException e) {\n            if (event instanceof DomainEvent.ConstructionEvent) {\n                throw e;\n            }\n            ensureInvariant(e);\n        }\n\n        if (!(event instanceof DomainEvent.DestructionEvent))\n            ensureInvariant();\n\n        addDomainEvent(event);\n    }\n    //endregion\n\n    private void ensureInvariant(RuntimeException leadingException) {\n        try {\n            ensureInvariant();\n            if (null != leadingException)\n                throw leadingException;\n        } catch (ClassInvariantViolationException ce) {\n            ce.initCause(leadingException);\n            throw ce;\n        }\n    }\n\n    //region hook methods\n    protected void ensureInvariant() {\n    }\n\n    protected abstract void when(E event);\n    //endregion\n\n    //region: event sourcing\n    abstract public String getCategory();\n\n    public final String getStreamName() {\n        return getCategory() + \"-\" + getId().toString();\n    }\n\n    public static String getStreamName(String category, String id) {\n        return category + \"-\" + id;\n    }\n    //endregion\n}\n\n```\n\n另外需要透過 uContract 中的 tw.teddysoft.ucontract.Contract 搭配 EsAggregateRoot 的設計為 Aggregate Root撰寫DBC合約，包含 preconditions, postconditions, and aggregate invariants。\nContract class 的程式碼如下：\n```\n/**\n * {@code Contract} is a class for specifying pre-conditions, post-conditions\n * and class invariants.\n *\n * @author Teddy Chen\n * @author EzKanban Team\n * @see PreconditionViolationException\n * @see PostconditionViolationException\n * @see ClassInvariantViolationException\n * @see CheckViolationException\n * @since 0.1\n */\npublic class Contract {\n    /**\n     * The constant {@code DBC} is for controlling the evaluation of contracts.\n     * The default value of {@code DBC} is {@code true};\n     * When environment variable DBC=on, {@code DBC} is {@code true},\n     * and contracts will be evaluated.\n     * When environment variable DBC=off, {@code DBC} is {@code false},\n     * and contracts will not be evaluated.\n     */\n    public static boolean DBC;\n\n    /**\n     * The constant {@code CHECK_PRE} is for controlling the evaluation\n     * of pre-conditions.\n     * The default value of {@code CHECK_PRE} is {@code true};\n     * When {@code CHECK_PRE} is {@code true}, pre-condition will be evaluated.\n     * When {@code CHECK_PRE} is {@code false}, pre-condition\n     * will not be evaluated.\n     */\n    public static boolean CHECK_PRE;\n\n    /**\n     * The constant {@code CHECK_POST} is for controlling the evaluation\n     * of post-conditions.\n     * The default value of {@code CHECK_POST} is {@code true};\n     * When {@code CHECK_POST} is {@code true}, post-condition\n     * will be evaluated.\n     * When {@code CHECK_POST} is {@code false}, post-condition\n     * will not be evaluated.\n     */\n    public static boolean CHECK_POST;\n\n    /**\n     * The constant {@code CHECK_INV} is for controlling the evaluation\n     * of class invariants.\n     * The default value of {@code CHECK_INV} is {@code true};\n     * When {@code CHECK_INV} is {@code true}, class invariants\n     * will be evaluated.\n     * When {@code CHECK_INV} is {@code false}, class invariants\n     * will not be evaluated.\n     */\n    public static boolean CHECK_INV;\n\n    /**\n     * The constant {@code CHECK_CHECK} is for controlling the evaluation\n     * of keyword check.\n     * The default value of {@code CHECK_CHECK} is {@code true};\n     * When {@code CHECK_CHECK} is {@code true}, keyword check\n     * will be evaluated.\n     * When {@code CHECK_CHECK} is {@code false}, keyword check\n     * will not be evaluated.\n     */\n    public static boolean CHECK_CHECK;\n\n    /**\n     * The constant {@code GENERATE_DOC} is for controlling the documentation\n     * generating after execution of contract.\n     * The default value of {@code GENERATE_DOC} is {@code false};\n     * When {@code GENERATE_DOC} is {@code true}, the document\n     * will be generated.\n     * When {@code GENERATE_DOC} is {@code false}, the document\n     * will not be generated.\n     */\n    public static boolean GENERATE_DOC;\n\n    /**\n     * The constant {@code runtime} is for storing the documentation string.\n     */\n    public static Map<String, List<String>> runtime = new HashMap<>();\n\n    private static final JsonMapper mapper;\n\n    static {\n        Logger logger = Logger.getLogger(\"uContract\");\n        DBC = true;\n        GENERATE_DOC = false;\n        var dbc_env = System.getenv(\"DBC\");\n        logger.info(\"DBC ENV: \" + dbc_env);\n        if (\"off\".equals(dbc_env)) {\n            DBC = false;\n        }\n\n        var doc = System.getenv(\"DBC_DOC\");\n        logger.info(\"DBC_DOC: \" + doc);\n        if (\"on\".equals(doc)) {\n            GENERATE_DOC = true;\n        }\n\n        CHECK_PRE = DBC;\n        CHECK_POST = DBC;\n        CHECK_INV = DBC;\n        CHECK_CHECK = DBC;\n\n        var pre_env = System.getenv(\"DBC_PRE\");\n        if (\"off\".equals(pre_env)){\n            logger.info(\"PRE ENV: \" + pre_env);\n            CHECK_PRE = false;\n        }\n\n        var post_env = System.getenv(\"DBC_POST\");\n        if (\"off\".equals(post_env)){\n            logger.info(\"POST ENV: \" + post_env);\n            CHECK_POST = false;\n        }\n\n        var inv_env = System.getenv(\"DBC_INV\");\n        if (\"off\".equals(inv_env)){\n            logger.info(\"INV ENV: \" + inv_env);\n            CHECK_INV = false;\n        }\n\n        var check_env = System.getenv(\"DBC_CHECK\");\n        if (\"off\".equals(check_env)){\n            logger.info(\"CHECK ENV: \" + check_env);\n            CHECK_CHECK = false;\n        }\n\n        mapper = JsonMapper.builder()\n                .addModule(new ParameterNamesModule())\n                .addModule(new Jdk8Module())\n                .addModule(new JavaTimeModule())\n                .configure(SerializationFeature.WRITE_DATES_AS_TIMESTAMPS, false)\n                .configure(JsonParser.Feature.ALLOW_UNQUOTED_FIELD_NAMES, true)\n                .build();\n        mapper.setVisibility(PropertyAccessor.FIELD, JsonAutoDetect.Visibility.ANY);\n    }\n\n    /**\n     * Check a condition at a certain stage.\n     *\n     * @param annotation the description of the check\n     * @param assertion a lambda expression to represent the assertion\n     *                  of the pre-condition\n     * @throws CheckViolationException if the assertion returns false\n     */\n    public static void check(String annotation, BooleanSupplier assertion) {\n        var msg = format(\"Check %s\", annotation);\n        checkImpl(msg, assertion);\n    }\n\n    /**\n     * Check if the operation is supported or not.\n     *\n     * @param runnable the function to check if it is unsupported.\n     * @return {@code true} if the operation is unsupported.\n     */\n    public static boolean checkUnsupportedOperation(Runnable runnable) {\n        try {\n            runnable.run();\n            return false;\n        } catch (UnsupportedOperationException e) {\n            return true;\n        } catch (Exception e) {\n            return false;\n        }\n    }\n\n    /**\n     * Check a pre-condition.\n     *\n     * @param annotation the description of the pre-condition\n     * @param assertion  a lambda expression to represent the assertion\n     *                   of the pre-condition\n     * @throws PreconditionViolationException\n     *          if the {@code assertion} returns {@code false}\n     */\n    public static void require(String annotation, BooleanSupplier assertion) {\n        var msg = format(\"Require %s\", annotation);\n        recordContract(msg);\n        requireImpl(msg, assertion);\n    }\n\n    /**\n     * Check a pre-condition of an object cannot be {@code null}.\n     *\n     * @param annotation the description of the pre-condition\n     * @param obj        the object\n     * @throws PreconditionViolationException\n     *          if the {@code obj} is {@code null}\n     */\n    public static void requireNotNull(String annotation, Object obj){\n        var msg = format(\"Require [%s] cannot be null\", annotation);\n        recordContract(msg);\n        requireImpl(msg, () -> null != obj);\n    }\n\n    /**\n     * Check a pre-condition of a string cannot be empty.\n     *\n     * @param annotation the description of the pre-condition\n     * @param str        the string\n     * @throws PreconditionViolationException if the {@code str} is empty\n     */\n    public static void requireNotEmpty(String annotation, String str) {\n        var msg = format(\"Require [%s] cannot be empty\", annotation);\n        recordContract(msg);\n        requireImpl(msg, () -> !str.isEmpty());\n    }\n\n    /**\n     * Check a post-condition.\n     *\n     * @param annotation the description of the post-condition\n     * @param assertion  a lambda expression to represent the assertion\n     *                   of the post-condition\n     * @throws PostconditionViolationException\n     *          if the {@code assertion} returns {@code false}\n     */\n    public static void ensure(String annotation, BooleanSupplier assertion) {\n        var msg = format(\"Ensure %s\", annotation);\n        recordContract(msg);\n        ensureImpl(msg, assertion);\n    }\n\n    /**\n     * Check a post-condition of an object cannot be {@code null}.\n     *\n     * @param annotation the description of the post-condition\n     * @param obj        the object\n     * @throws PostconditionViolationException\n     *          if the {@code obj} is {@code null}\n     */\n    public static void ensureNotNull(String annotation, Object obj){\n        var msg = format(\"Ensure [%s] cannot be null\", annotation);\n        recordContract(msg);\n        ensureImpl(msg, () -> null != obj);\n    }\n\n    /**\n     * Check a post-condition and return {@code result}.\n     *\n     * @param <T>         the type of {@code result}\n     * @param annotation  the description of the post-condition\n     * @param result      the returning result\n     * @param assertion   a lambda expression that accepts the {@code result}\n     *                    to represent the assertion of the post-condition\n     * @return the {@code result} if the {@code assertion} is {@code true}\n     * @throws PostconditionViolationException\n     *          if the {@code assertion} is {@code false}\n     */\n    public static <T> T ensureResult(String annotation, T result, Function<T, Boolean> assertion) {\n        var msg = format(\"Ensure result [%s]\", annotation);\n        recordContract(msg);\n        return ensureResultImpl(msg, result, assertion);\n    }\n\n    /**\n     * Check if {@code resultingCollection} is immutable in post-condition.\n     *\n     * @param <T>                 the type of {@code resultingCollection}\n     * @param resultingCollection the returning Collection\n     * @return the {@code resultingCollection} if it is immutable\n     * @throws PostconditionViolationException\n     *          if {@code resultingCollection} is not immutable\n     */\n    public static <T> T ensureImmutableCollection(T resultingCollection) {\n        var msg = format(\"Ensure resultingCollection is an immutable collection\");\n        recordContract(msg);\n        return ensureResultImpl(msg, resultingCollection, x -> x.getClass().getSimpleName().startsWith(\"Unmodifiable\") || x.getClass().getSimpleName().startsWith(\"ListN\"));\n    }\n\n    /**\n     * Check the fields except for {@code assignables} are not changed.\n     *\n     * @param <T> the type of {@code state} and {@code oldState}\n     * @param state the object after changing state\n     * @param oldState the object before changing state\n     * @param assignables regular expressions for name of the fields that can be changed\n     * @throws PostconditionViolationException\n     *          if any field not assignable is changed\n     */\n    public static <T> void ensureAssignable(T state, T oldState, String ... assignables) {\n        var msg = \"\";\n        recordContract(msg);\n        ensureImpl(msg, () -> {\n            try {\n                assertThat(state)\n                        .usingRecursiveComparison()\n                        .ignoringFieldsMatchingRegexes(assignables)\n                        .isEqualTo(oldState);\n            } catch (AssertionError e) {\n                throw new PostconditionViolationException(e.getMessage());\n            }\n            return true;\n        });\n    }\n\n    /**\n     * Check a class invariant.\n     *\n     * @param annotation  the description of the class invariant\n     * @param assertion   a lambda expression to represent the assertion\n     *                    of the class invariant\n     * @throws ClassInvariantViolationException\n     *          if the {@code assertion} is {@code false}\n     */\n    public static void invariant(String annotation, BooleanSupplier assertion) {\n        var msg = format(\"Ensure Invariant [%s]\", annotation);\n        recordContract(msg);\n        invariantImpl(msg, assertion);\n    }\n\n    /**\n     * Check a class invariant of an object cannot be {@code null}.\n     *\n     * @param annotation the description of the class invariant\n     * @param obj        the object\n     * @throws ClassInvariantViolationException\n     *          if the {@code obj} is {@code null}\n     */\n    public static void invariantNotNull(String annotation, Object obj) {\n        var msg = format(\"Invariant [%s] cannot be null\", annotation);\n        recordContract(msg);\n        invariantImpl(msg, () -> null != obj);\n    }\n\n    /**\n     * Return the boolean value of the assertion to tell the caller\n     * whether to reject the operation and return immediately.\n     *\n     * @param annotation the description of the rejection\n     * @param assertion  a lambda expression to represent the assertion\n     *                   for rejection\n     * @return {@code true} when the caller have to reject the operation.\n     */\n    public static boolean reject(String annotation, BooleanSupplier assertion) {\n        recordContract(format(\"Reject %s\", annotation));\n        return assertion.getAsBoolean();\n    }\n\n    /**\n     * To represent the semantic of <b>imply</b>.\n     * {@code a} implies {@code b} means that if {@code a} is {@code true}\n     * then {@code b} is {@code true}.\n     *\n     * @param a the lambda expression to represent the assertion\n     * @param b the lambda expression to represent the assertion\n     * @return {@code true} when {@code a} implies {@code b}\n     */\n    public static boolean imply(BooleanSupplier a, BooleanSupplier b) {\n        return !a.getAsBoolean() || b.getAsBoolean();\n    }\n\n    /**\n     * To represent the semantic of <b>follows from</b>.\n     * {@code a} follows from {@code b} means that if {@code b} is {@code true}\n     * then {@code a} is {@code true}.\n     *\n     * @param a the lambda expression to represent the assertion\n     * @param b the lambda expression to represent the assertion\n     * @return {@code true} when {@code a} follows from {@code b}\n     */\n    public static boolean followsFrom(BooleanSupplier a, BooleanSupplier b) {\n        return a.getAsBoolean() || !b.getAsBoolean();\n    }\n\n    /**\n     * To represent the semantic of {@code a} <b>if and only if</b> {@code b}.\n     * {@code a} if and only if {@code b} means that\n     * {@code a} is {@code true} if {@code b} is {@code true}, and\n     * {@code b} is {@code true} if {@code a} is {@code true}.\n     *\n     * @param a the lambda expression to represent the assertion\n     * @param b the lambda expression to represent the assertion\n     * @return {@code true} when {@code a} if and only if {@code b}\n     */\n    public static boolean ifAndOnlyIf(BooleanSupplier a, BooleanSupplier b) {\n        var aResult = a.getAsBoolean();\n        var bResult = b.getAsBoolean();\n        return (aResult && bResult) || (!aResult && !bResult);\n    }\n\n    /**\n     * Denote the value that supplier has which is used in post-conditions.\n     *\n     * @param <T> the type of object that {@code supplier} provides\n     * @param supplier a lambda expression provides an object\n     * @return a deep copy of the object provided by {@code supplier}\n     */\n    public static <T> T old(Supplier<T> supplier) {\n        if (!CHECK_POST) {\n            return null;\n        }\n        if (isCalledByAssertion(1)) {\n            return null;\n        }\n        var json = asBytes(supplier.get());\n        return (T) readJsonAs(json, supplier.get().getClass());\n    }\n\n    private static <T> T ensureResultImpl(String annotation, T returnValue, Function<T, Boolean> assertion) {\n        if (!CHECK_POST) return returnValue;\n        if (isCalledByAssertion(2)) {\n            return returnValue;\n        }\n        if (assertion.apply(returnValue)) return returnValue;\n        throw new PostconditionViolationException(annotation);\n    }\n\n    private static void ensureImpl(String annotation, BooleanSupplier assertion) {\n        if (!CHECK_POST)\n            return;\n        if (isCalledByAssertion(2)) {\n            return;\n        }\n        if (!assertion.getAsBoolean()) {\n            throw new PostconditionViolationException(annotation);\n        }\n    }\n\n    private static void invariantImpl(String annotation, BooleanSupplier assertion) {\n        if (!CHECK_INV)\n            return;\n        if (isCalledByAssertion(2)) {\n            return;\n        }\n        if (!assertion.getAsBoolean()) {\n            throw new ClassInvariantViolationException(annotation);\n        }\n    }\n\n    private static void checkImpl(String annotation, BooleanSupplier assertion) {\n        if (!CHECK_CHECK)\n            return;\n        if (isCalledByAssertion(2)) {\n            return;\n        }\n        if (!assertion.getAsBoolean()) {\n            throw new CheckViolationException(annotation);\n        }\n    }\n\n    private static void requireImpl(String annotation, BooleanSupplier assertion) {\n        if (!CHECK_PRE)\n            return;\n        if (isCalledByAssertion(2)) {\n            return;\n        }\n        if (!assertion.getAsBoolean()) {\n            throw new PreconditionViolationException(annotation);\n        }\n    }\n\n    private static void recordContract(String newContract) {\n        if (!GENERATE_DOC) return;\n\n        final StackWalker.StackFrame stack = StackWalker.getInstance()\n                .walk(s -> s.limit(3).skip(2).collect(Collectors.toList())).get(0);\n        String key = stack.getClassName() + \"::\" + stack.getMethodName();\n\n        if (runtime.containsKey(key)){\n            for(var existingContract : runtime.get(key)){\n                if (isDuplicatedContract(existingContract, newContract))\n                    return;\n            }\n            runtime.get(key).add(newContract);\n        }else{\n            runtime.put(key, new ArrayList<>());\n            runtime.get(key).add(newContract);\n        }\n    }\n\n\n    private static boolean isDuplicatedContract(String str1, String str2){\n        return eraseArguments(str1).equals(eraseArguments(str2));\n    }\n\n\n    private static String eraseArguments(String runtimeContract){\n        String regular = \"'[^\\\\\\\\s']*'\";\n        Pattern pattern = Pattern.compile(regular);\n        Matcher matcher = pattern.matcher(runtimeContract);\n        List<String> foundTokens = new ArrayList<>();\n        while (matcher.find()) {\n            foundTokens.add(matcher.group(0));\n        }\n        for(var each : foundTokens){\n            runtimeContract = runtimeContract.replace(each, \"\");\n        }\n        return runtimeContract;\n    }\n\n    private static boolean isCalledByAssertion(int NumberOfStacksInCurrentAssertion) {\n        StackTraceElement[] stackTraceElements = Thread.currentThread().getStackTrace();\n        var contractClass = stackTraceElements[1].getClassName();\n        final int NUMBER_OF_STACK_OF_THIS_METHOD = 1;\n        var totalNumbersContractsOfStacks = Arrays.stream(stackTraceElements).filter(x -> x.getClassName().equals(contractClass)).toList().size();\n        if ((totalNumbersContractsOfStacks - NUMBER_OF_STACK_OF_THIS_METHOD) > NumberOfStacksInCurrentAssertion) {\n            return true;\n        }\n        return false;\n    }\n\n    private static byte[] asBytes(Object value){\n        try {\n            return mapper.writeValueAsBytes(value);\n        } catch (JsonProcessingException e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static <A> A readJsonAs(byte[] content, Class<A> clazz) {\n\n        try {\n            return mapper.readValue(content, clazz);\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n    }\n}\n```\n\n所有領域事件實作 ezddd-core的 tw.teddysoft.ezddd.entity.DomainEvent 介面， value object 實作 ezddd-core 的 tw.teddysoft.ezddd.entity.Entity。\n此外，所有 Card 相關的領域事件都需要繼承自一個 CardEvents 的介面，並使用 record實作。\n請產生實作需求所需的所有類別，包含但不限 entities, value objects, domain events。\n根據您的需求，我將創建Card領域模型及所有相關類別，以符合DDD、Clean Architecture和BDD開發原則。首先我將設計核心的Card實體，然後是相關的值對象和領域事件。\n\n## 1. 領域事件基礎介面\n\n首先創建Card領域事件的基礎介面:\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardEvents.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport tw.teddysoft.ezddd.entity.DomainEvent;\n\npublic interface CardEvents extends DomainEvent {\n    String getCardId();\n}\n```\n\n## 2. 值對象 (Value Objects)\n\n然後實現所需的值對象:\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardId.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport tw.teddysoft.ezddd.entity.Entity;\nimport java.util.Objects;\nimport java.util.UUID;\n\npublic class CardId implements Entity<CardId> {\n    private final String id;\n\n    public CardId(String id) {\n        this.id = id;\n    }\n\n    public static CardId create() {\n        return new CardId(UUID.randomUUID().toString());\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        CardId cardId = (CardId) o;\n        return Objects.equals(id, cardId.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n\n    @Override\n    public boolean sameIdentityAs(CardId other) {\n        return equals(other);\n    }\n\n    @Override\n    public String toString() {\n        return id;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/BoardId.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport tw.teddysoft.ezddd.entity.Entity;\nimport java.util.Objects;\nimport java.util.UUID;\n\npublic class BoardId implements Entity<BoardId> {\n    private final String id;\n\n    public BoardId(String id) {\n        this.id = id;\n    }\n\n    public static BoardId create() {\n        return new BoardId(UUID.randomUUID().toString());\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        BoardId boardId = (BoardId) o;\n        return Objects.equals(id, boardId.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n\n    @Override\n    public boolean sameIdentityAs(BoardId other) {\n        return equals(other);\n    }\n\n    @Override\n    public String toString() {\n        return id;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/WorkflowId.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport tw.teddysoft.ezddd.entity.Entity;\nimport java.util.Objects;\nimport java.util.UUID;\n\npublic class WorkflowId implements Entity<WorkflowId> {\n    private final String id;\n\n    public WorkflowId(String id) {\n        this.id = id;\n    }\n\n    public static WorkflowId create() {\n        return new WorkflowId(UUID.randomUUID().toString());\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        WorkflowId that = (WorkflowId) o;\n        return Objects.equals(id, that.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n\n    @Override\n    public boolean sameIdentityAs(WorkflowId other) {\n        return equals(other);\n    }\n\n    @Override\n    public String toString() {\n        return id;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/LaneId.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport tw.teddysoft.ezddd.entity.Entity;\nimport java.util.Objects;\nimport java.util.UUID;\n\npublic class LaneId implements Entity<LaneId> {\n    private final String id;\n\n    public LaneId(String id) {\n        this.id = id;\n    }\n\n    public static LaneId create() {\n        return new LaneId(UUID.randomUUID().toString());\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        LaneId laneId = (LaneId) o;\n        return Objects.equals(id, laneId.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n\n    @Override\n    public boolean sameIdentityAs(LaneId other) {\n        return equals(other);\n    }\n\n    @Override\n    public String toString() {\n        return id;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/TagId.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport tw.teddysoft.ezddd.entity.Entity;\nimport java.util.Objects;\nimport java.util.UUID;\n\npublic class TagId implements Entity<TagId> {\n    private final String id;\n\n    public TagId(String id) {\n        this.id = id;\n    }\n\n    public static TagId create() {\n        return new TagId(UUID.randomUUID().toString());\n    }\n\n    public String getId() {\n        return id;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        TagId tagId = (TagId) o;\n        return Objects.equals(id, tagId.id);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(id);\n    }\n\n    @Override\n    public boolean sameIdentityAs(TagId other) {\n        return equals(other);\n    }\n\n    @Override\n    public String toString() {\n        return id;\n    }\n}\n```\n\n## 3. 卡片類型枚舉\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardType.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\npublic enum CardType {\n    STANDARD, \n    EXPEDITE\n}\n```\n\n## 4. 卡片阻塞者類型\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/Blocker.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\nimport java.util.Objects;\n\npublic class Blocker {\n    private final String userId;\n    private final Instant blockTime;\n    private String reason;\n\n    public Blocker(String userId, Instant blockTime, String reason) {\n        this.userId = userId;\n        this.blockTime = blockTime;\n        this.reason = reason;\n    }\n\n    public String getUserId() {\n        return userId;\n    }\n\n    public Instant getBlockTime() {\n        return blockTime;\n    }\n\n    public String getReason() {\n        return reason;\n    }\n\n    public void changeReason(String newReason) {\n        this.reason = newReason;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Blocker blocker = (Blocker) o;\n        return Objects.equals(userId, blocker.userId) && \n               Objects.equals(blockTime, blocker.blockTime) && \n               Objects.equals(reason, blocker.reason);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(userId, blockTime, reason);\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/Unblocker.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\nimport java.util.Objects;\n\npublic class Unblocker {\n    private final String userId;\n    private final Instant unblockTime;\n\n    public Unblocker(String userId, Instant unblockTime) {\n        this.userId = userId;\n        this.unblockTime = unblockTime;\n    }\n\n    public String getUserId() {\n        return userId;\n    }\n\n    public Instant getUnblockTime() {\n        return unblockTime;\n    }\n\n    @Override\n    public boolean equals(Object o) {\n        if (this == o) return true;\n        if (o == null || getClass() != o.getClass()) return false;\n        Unblocker unblocker = (Unblocker) o;\n        return Objects.equals(userId, unblocker.userId) && \n               Objects.equals(unblockTime, unblocker.unblockTime);\n    }\n\n    @Override\n    public int hashCode() {\n        return Objects.hash(userId, unblockTime);\n    }\n}\n```\n\n## 5. 領域事件 (Domain Events)\n\n現在實現所有必要的領域事件:\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardCreatedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport tw.teddysoft.ezddd.entity.DomainEvent;\nimport java.time.Instant;\n\npublic record CardCreatedEvent(\n    String cardId,\n    String boardId,\n    String workflowId,\n    String laneId,\n    CardType cardType,\n    String title,\n    String description,\n    int version,\n    int order,\n    String shadowOfCardId,\n    Instant occurredOn\n) implements CardEvents, DomainEvent.ConstructionEvent {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardDeletedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport tw.teddysoft.ezddd.entity.DomainEvent;\nimport java.time.Instant;\n\npublic record CardDeletedEvent(\n    String cardId,\n    int version,\n    Instant occurredOn\n) implements CardEvents, DomainEvent.DestructionEvent {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardMovedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record CardMovedEvent(\n    String cardId,\n    String fromWorkflowId,\n    String toWorkflowId,\n    String fromLaneId,\n    String toLaneId,\n    int oldOrder,\n    int newOrder,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardAssignedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record CardAssignedEvent(\n    String cardId,\n    String assigneeId,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardUnassignedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record CardUnassignedEvent(\n    String cardId,\n    String assigneeId,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardBlockedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record CardBlockedEvent(\n    String cardId,\n    String userId,\n    String reason,\n    Instant blockTime,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardUnblockedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record CardUnblockedEvent(\n    String cardId,\n    String userId,\n    Instant unblockTime,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/BlockerReasonChangedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record BlockerReasonChangedEvent(\n    String cardId,\n    String oldReason,\n    String newReason,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/TagAssignedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record TagAssignedEvent(\n    String cardId,\n    String tagId,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/TagUnassignedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record TagUnassignedEvent(\n    String cardId,\n    String tagId,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardTypeChangedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record CardTypeChangedEvent(\n    String cardId,\n    CardType oldType,\n    CardType newType,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardNoteChangedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record CardNoteChangedEvent(\n    String cardId,\n    String oldNote,\n    String newNote,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardDescriptionChangedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record CardDescriptionChangedEvent(\n    String cardId,\n    String oldDescription,\n    String newDescription,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardEstimateChangedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record CardEstimateChangedEvent(\n    String cardId,\n    String oldEstimation,\n    String newEstimation,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/CardDeadlineChangedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\n\npublic record CardDeadlineChangedEvent(\n    String cardId,\n    LocalDateTime oldDeadline,\n    LocalDateTime newDeadline,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return cardId;\n    }\n}\n```\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/ChildAttachedEvent.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport java.time.Instant;\n\npublic record ChildAttachedEvent(\n    String parentCardId,\n    String childCardId,\n    int version,\n    Instant occurredOn\n) implements CardEvents {\n    \n    @Override\n    public Instant getOccurredOn() {\n        return occurredOn;\n    }\n    \n    @Override\n    public String getCardId() {\n        return parentCardId;\n    }\n}\n```\n\n## 6. 卡片實體 (Card Aggregate Root)\n\n最後，實現卡片聚合根:\n\n```java\n// src/main/java/tw/teddysoft/ai/bdd/cards/entity/Card.java\npackage tw.teddysoft.ai.bdd.cards.entity;\n\nimport tw.teddysoft.ezddd.entity.DomainEvent;\nimport tw.teddysoft.ezddd.entity.EsAggregateRoot;\nimport tw.teddysoft.ucontract.Contract;\n\nimport java.time.Instant;\nimport java.time.LocalDateTime;\nimport java.util.*;\n\npublic class Card extends EsAggregateRoot<CardId, DomainEvent> {\n    private static final String CATEGORY = \"card\";\n\n    private CardId id;\n    private BoardId boardId;\n    private WorkflowId workflowId;\n    private LaneId laneId;\n    private CardType cardType;\n    private String title;\n    private String description;\n    private String note;\n    private String estimation;\n    private LocalDateTime deadline;\n    private int version;\n    private int order;\n    private CardId shadowOfCardId;\n    private Set<String> assignees;\n    private Set<TagId> tags;\n    private List<CardId> children;\n    private boolean blocked;\n    private Blocker blocker;\n    private Unblocker unblocker;\n\n    // Constructor for new cards\n    public Card(CardId id, BoardId boardId, WorkflowId workflowId, LaneId laneId, \n                String title, String description, int order, CardId shadowOfCardId) {\n        Contract.requireNotNull(\"Card ID\", id);\n        Contract.requireNotNull(\"Board ID\", boardId);\n        Contract.requireNotNull(\"Workflow ID\", workflowId);\n        Contract.requireNotNull(\"Lane ID\", laneId);\n        Contract.requireNotNull(\"Title\", title);\n        Contract.require(\"Title cannot be empty\", () -> !title.trim().isEmpty());\n        \n        apply(new CardCreatedEvent(\n            id.getId(),\n            boardId.getId(),\n            workflowId.getId(),\n            laneId.getId(),\n            CardType.STANDARD,\n            title,\n            description,\n            1,\n            order,\n            shadowOfCardId != null ? shadowOfCardId.getId() : null,\n            Instant.now()\n        ));\n    }\n\n    // Constructor for event sourcing\n    public Card(List<DomainEvent> events) {\n        super(events);\n    }\n\n    protected Card() {\n        super();\n    }\n\n    @Override\n    protected void when(DomainEvent event) {\n        if (event instanceof CardCreatedEvent e) {\n            whenCardCreated(e);\n        } else if (event instanceof CardMovedEvent e) {\n            whenCardMoved(e);\n        } else if (event instanceof CardAssignedEvent e) {\n            whenCardAssigned(e);\n        } else if (event instanceof CardUnassignedEvent e) {\n            whenCardUnassigned(e);\n        } else if (event instanceof CardBlockedEvent e) {\n            whenCardBlocked(e);\n        } else if (event instanceof CardUnblockedEvent e) {\n            whenCardUnblocked(e);\n        } else if (event instanceof BlockerReasonChangedEvent e) {\n            whenBlockerReasonChanged(e);\n        } else if (event instanceof TagAssignedEvent e) {\n            whenTagAssigned(e);\n        } else if (event instanceof TagUnassignedEvent e) {\n            whenTagUnassigned(e);\n        } else if (event instanceof CardTypeChangedEvent e) {\n            whenCardTypeChanged(e);\n        } else if (event instanceof CardNoteChangedEvent e) {\n            whenCardNoteChanged(e);\n        } else if (event instanceof CardDescriptionChangedEvent e) {\n            whenCardDescriptionChanged(e);\n        } else if (event instanceof CardEstimateChangedEvent e) {\n            whenCardEstimateChanged(e);\n        } else if (event instanceof CardDeadlineChangedEvent e) {\n            whenCardDeadlineChanged(e);\n        } else if (event instanceof ChildAttachedEvent e) {\n            whenChildAttached(e);\n        } else if (event instanceof CardDeletedEvent e) {\n            whenCardDeleted(e);\n        }\n    }\n\n    private void whenCardCreated(CardCreatedEvent event) {\n        this.id = new CardId(event.cardId());\n        this.boardId = new BoardId(event.boardId());\n        this.workflowId = new WorkflowId(event.workflowId());\n        this.laneId = new LaneId(event.laneId());\n        this.cardType = event.cardType();\n        this.title = event.title();\n        this.description = event.description();\n        this.version = event.version();\n        this.order = event.order();\n        this.shadowOfCardId = event.shadowOfCardId() != null ? new CardId(event.shadowOfCardId()) : null;\n        this.assignees = new HashSet<>();\n        this.tags = new HashSet<>();\n        this.children = new ArrayList<>();\n        this.blocked = false;\n        this.blocker = null;\n        this.unblocker = null;\n        this.note = \"\";\n        this.estimation = \"\";\n    }\n\n    private void whenCardMoved(CardMovedEvent event) {\n        this.workflowId = new WorkflowId(event.toWorkflowId());\n        this.laneId = new LaneId(event.toLaneId());\n        this.order = event.newOrder();\n        this.version = event.version();\n    }\n\n    private void whenCardAssigned(CardAssignedEvent event) {\n        this.assignees.add(event.assigneeId());\n        this.version = event.version();\n    }\n\n    private void whenCardUnassigned(CardUnassignedEvent event) {\n        this.assignees.remove(event.assigneeId());\n        this.version = event.version();\n    }\n\n    private void whenCardBlocked(CardBlockedEvent event) {\n        this.blocked = true;\n        this.blocker = new Blocker(event.userId(), event.blockTime(), event.reason());\n        this.version = event.version();\n    }\n\n    private void whenCardUnblocked(CardUnblockedEvent event) {\n        this.blocked = false;\n        this.unblocker = new Unblocker(event.userId(), event.unblockTime());\n        this.version = event.version();\n    }\n\n    private void whenBlockerReasonChanged(BlockerReasonChangedEvent event) {\n        if (this.blocker != null) {\n            this.blocker.changeReason(event.newReason());\n        }\n        this.version = event.version();\n    }\n\n    private void whenTagAssigned(TagAssignedEvent event) {\n        this.tags.add(new TagId(event.tagId()));\n        this.version = event.version();\n    }\n\n    private void whenTagUnassigned(TagUnassignedEvent event) {\n        this.tags.removeIf(tagId -> tagId.getId().equals(event.tagId()));\n        this.version = event.version();\n    }\n\n    private void whenCardTypeChanged(CardTypeChangedEvent event) {\n        this.cardType = event.newType();\n        this.version = event.version();\n    }\n\n    private void whenCardNoteChanged(CardNoteChangedEvent event) {\n        this.note = event.newNote();\n        this.version = event.version();\n    }\n\n    private void whenCardDescriptionChanged(CardDescriptionChangedEvent event) {\n        this.description = event.newDescription();\n        this.version = event.version();\n    }\n\n    private void whenCardEstimateChanged(CardEstimateChangedEvent event) {\n        this.estimation = event.newEstimation();\n        this.version = event.version();\n    }\n\n    private void whenCardDeadlineChanged(CardDeadlineChangedEvent event) {\n        this.deadline = event.newDeadline();\n        this.version = event.version();\n    }\n\n    private void whenChildAttached(ChildAttachedEvent event) {\n        this.children.add(new CardId(event.childCardId()));\n        this.version = event.version();\n    }\n\n    private void whenCardDeleted(CardDeletedEvent event) {\n        this.version = event.version();\n    }\n\n    // Business Methods\n    public void move(WorkflowId newWorkflowId, LaneId newLaneId, int newOrder, int expectedVersion) {\n        Contract.requireNotNull(\"New workflow ID\", newWorkflowId);\n        Contract.requireNotNull(\"New lane ID\", newLaneId);\n        Contract.require(\"New order must be positive\", () -> newOrder >= 0);\n        Contract.require(\"Expected version must match current version\", () -> expectedVersion == this.version);\n\n        if (this.workflowId.equals(newWorkflowId) && this.laneId.equals(newLaneId) && this.order == newOrder) {\n            return; // No change, no event\n        }\n\n        apply(new CardMovedEvent(\n            this.id.getId(),\n            this.workflowId.getId(),\n            newWorkflowId.getId(),\n            this.laneId.getId(),\n            newLaneId.getId(),\n            this.order,\n            newOrder,\n            this.version + 1,\n            Instant.now()\n        ));\n    }\n\n    public void assignTo(String assigneeId) {\n        Contract.requireNotNull(\"Assignee ID\", assigneeId);\n        Contract.require(\"Assignee must not already be assigned\", () -> !assignees.contains(assigneeId));\n\n        apply(new CardAssignedEvent(\n            this.id.getId(),\n            assigneeId,\n            this.version + 1,\n            Instant.now()\n        ));\n    }\n\n    public void unassign(String assigneeId) {\n        Contract.requireNotNull(\"Assignee ID\", assigneeId);\n        Contract.require(\"Assignee must be assigned\", () -> assignees.contains(assigneeId));\n\n        apply(new CardUnassignedEvent(\n            this.id.getId(),\n            assigneeId,\n            this.version + 1,\n            Instant.now()\n        ));\n    }\n\n    public void block(String userId, String reason) {\n        Contract.requireNotNull(\"User ID\", userId);\n        Contract.requireNotNull(\"Reason\", reason);\n\n        apply(new CardBlockedEvent(\n            this.id.getId(),\n            userId,\n            reason,\n            Instant.now(),\n            this.version + 1,\n            Instant.now()\n        ));\n    }\n\n    public void unblock(String userId) {\n        Contract.requireNotNull(\"User ID\", userId);\n        Contract.require(\"Card must be blocked\", () -> this.blocked);\n\n        apply(new CardUnblockedEvent(\n            this.id.getId(),\n            userId,\n            Instant.now(),\n            this.version + 1,\n            Instant.now()\n        ));\n    }\n\n    public void changeBlockerReason(String newReason) {\n        Contract.requireNotNull(\"New reason\", newReason);\n        Contract.require(\"Card must be blocked\", () -> this.blocked);\n        Contract.require(\"\n\n\n\n\n","messages":[{"id":{"replica_id":0,"value":0},"start":0,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":110}}},{"id":{"replica_id":0,"value":85},"start":31118,"metadata":{"role":"assistant","status":"Done","timestamp":{"replica_id":0,"value":111}}},{"id":{"replica_id":0,"value":86},"start":57386,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":112}}},{"id":{"replica_id":0,"value":96},"start":57387,"metadata":{"role":"assistant","status":"Pending","timestamp":{"replica_id":0,"value":113}}},{"id":{"replica_id":0,"value":97},"start":57388,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":114}}},{"id":{"replica_id":0,"value":108},"start":57389,"metadata":{"role":"assistant","status":"Pending","timestamp":{"replica_id":0,"value":115}}},{"id":{"replica_id":0,"value":109},"start":57390,"metadata":{"role":"user","status":"Done","timestamp":{"replica_id":0,"value":116}}}],"summary":"Java Card Domain Model Implementation","slash_command_output_sections":[],"thought_process_output_sections":[]}